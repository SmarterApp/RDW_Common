package org.opentestsystem.rdw.group;

import com.google.common.base.Charsets;
import com.google.common.base.Joiner;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Ordering;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVParser;
import org.apache.commons.csv.CSVRecord;
import org.apache.commons.io.input.BOMInputStream;
import org.apache.commons.lang3.StringUtils;
import org.opentestsystem.rdw.security.PermissionScope;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Service;

import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.StringJoiner;
import java.util.stream.Collectors;

import static com.google.common.collect.Lists.newArrayList;
import static org.apache.commons.lang3.StringUtils.isBlank;
import static org.apache.commons.lang3.StringUtils.isNotBlank;
import static org.apache.commons.text.StringEscapeUtils.escapeJava;
import static org.opentestsystem.rdw.group.CsvValidationResult.failure;

/**
 * Default implementation of a CsvValidationService
 * <p>
 * To use this from a Spring application (without @Configuration shenanigans), ensure that there
 * is a NamedParameterJdbcTemplate bean named "warehouseJdbcTemplate" in the application context.
 * </p>
 */
@Service
public class DefaultCsvValidationService implements CsvValidationService {
    private static final Logger logger = LoggerFactory.getLogger(DefaultCsvValidationService.class);

    public final static String HeaderGroup = "group_name";
    public final static String HeaderSchool = "school_natural_id";
    public final static String HeaderYear = "school_year";
    public final static String HeaderSubject = "subject_code";
    public final static String HeaderSSID = "student_ssid";
    public final static String HeaderUser = "group_user_login";

    public final static List<String> RequiredHeaders = ImmutableList.of(
            HeaderGroup,
            HeaderSchool,
            HeaderYear,
            HeaderSubject,
            HeaderSSID,
            HeaderUser
    );
    static final int MaxStudentsPerGroup = 200;
    private static final String ValidationFailureFormat = "Row: %1$d Failure: %2$s";
    private static final String ValidationSuccessFormat = "%1$d group%2$s accepted for %3$s.";
    private static final String SimpleSuccessFormat = "%2$s";
    private static final String MoreFailuresFormat = "With %1$d additional validation failures";
    private static final String MoreSuccessesFormat = "With %1$d additional schools";
    private static final int MaxMessages = 100;

    private final SchoolRepository schoolRepository;
    private final Collection<Integer> schoolYears;
    private final Collection<String> subjectCodes;

    @Autowired
    public DefaultCsvValidationService(
            @Qualifier("warehouseJdbcSchoolRepository") final SchoolRepository schoolRepository,
            @Qualifier("warehouseJdbcSchoolYearRepository") final SchoolYearRepository schoolYearRepository,
            @Qualifier("warehouseJdbcSubjectRepository") final SubjectRepository subjectRepository) {
        this.schoolRepository = schoolRepository;
        this.schoolYears = schoolYearRepository.findAll();
        this.subjectCodes = subjectRepository.findAllCodes().stream().map(String::toLowerCase).collect(Collectors.toSet());
        this.subjectCodes.add("all");
    }

    @Override
    public List<CsvValidationResult> validate(final InputStream is, final PermissionScope permissionScope, final Map<String, String> fileProperties) {
        final List<CsvValidationResult> validationResults = newArrayList();

        try (final Reader reader = new InputStreamReader(new BOMInputStream(is), Charsets.UTF_8)) {
            final CSVParser parser = CSVFormat.DEFAULT
                    .withFirstRecordAsHeader()
                    .withIgnoreHeaderCase()
                    .parse(reader);

            final Iterator<CSVRecord> recordIterator = parser.iterator();
            if (!recordIterator.hasNext()) {
                validationResults.add(failure(0, "Empty file"));
                return validationResults;
            }

            // enhance file properties with the newline sequence and field delimiter (hard-coded for now)
            // note that the sequences are escaped, e.g. "\\r\\n"
            fileProperties.put("newline", escapeJava(parser.getFirstEndOfLine()));
            fileProperties.put("delimiter", escapeJava(","));

            final List<String> orderedHeaders = newArrayList(parser.getHeaderMap().keySet());
            final Ordering<String> ordering = Ordering.natural().onResultOf(header -> parser.getHeaderMap().get(header));
            orderedHeaders.sort(ordering);

            validationResults.addAll(validateHeaders(orderedHeaders));
            validationResults.addAll(validateRecords(recordIterator, permissionScope));

        } catch (final IOException exception) {
            logger.warn("Problem reading group file", exception);
            validationResults.add(failure(0, "Error reading file [" + exception.getMessage() + "]"));
        } catch (final IllegalArgumentException exception) {
            logger.warn("Problem parsing group file", exception);
            validationResults.add(failure(0, "File does not appear to be a valid CSV with a header row"));
        }

        return validationResults;
    }

    @Override
    public String toFailureMessage(final List<CsvValidationResult> failures) {
        return toMessage(failures, ValidationFailureFormat, MoreFailuresFormat);
    }

    @Override
    public String toSuccessMessage(final List<CsvValidationResult> successes) {
        return toMessage(successes, SimpleSuccessFormat, MoreSuccessesFormat);
    }

    List<CsvValidationResult> validateHeaders(final List<String> csvHeaders) {
        for (int i = 0; i < RequiredHeaders.size(); i++) {
            if (!RequiredHeaders.get(i).equalsIgnoreCase(csvHeaders.get(i))) {
                return newArrayList(failure(0,
                        "Invalid headers. Headers must be in order: [" + Joiner.on(",").join(RequiredHeaders) + "]"));
            }
        }
        return newArrayList();
    }

    List<CsvValidationResult> validateRecords(final Iterator<CSVRecord> recordIterator,
                                              final PermissionScope permissionScope) {

        final List<CsvValidationResult> failures = new ArrayList<>();
        final List<CsvValidationResult> successes = new ArrayList<>();

        final Set<String> schoolIds = schoolRepository.findAllNaturalIds(permissionScope);

        final Set<String> completedSchools = new HashSet<>();
        final Set<String> completedSchoolGroupYears = new HashSet<>();

        String currentSchool = null;
        String currentGroup = null;
        String currentSchoolGroupYear = null;
        String currentSchoolGroupYearSubject = null;
        int studentCountPerGroup = 0;
        int groupCountPerSchool = 0;
        long recordNumber = 0;

        while (recordIterator.hasNext()) {
            final CSVRecord record = recordIterator.next();
            final String school = record.get(HeaderSchool);
            final String group = record.get(HeaderGroup);
            final Integer schoolYear = getAsInt(record, HeaderYear);
            final String subject = StringUtils.stripToNull(record.get(HeaderSubject));
            recordNumber = record.getRecordNumber();

            //Require all key fields to be set
            if (!validateKeyValues(failures, school, group, schoolYear, recordNumber)) {
                continue;
            }

            //Validate the School Year
            if (!schoolYears.contains(schoolYear)) {
                addUniqueFailure(failures, recordNumber, "Invalid school year: " + schoolYear);
            }

            //Basic validation of Subject
            if (subject != null && !subjectCodes.contains(subject.toLowerCase())) {
                addUniqueFailure(failures, recordNumber, "Invalid subject: " + subject);
            }

            //Validate the School
            if (currentSchool == null || !currentSchool.equals(school)) {
                if (currentSchool != null) {
                    completedSchools.add(currentSchool);
                    successes.add(success(recordNumber, groupCountPerSchool, currentSchool));
                }
                completedSchoolGroupYears.clear();
                currentSchoolGroupYear = null;
                currentSchool = null;
                groupCountPerSchool = 0;

                if (validateSchool(failures, schoolIds, completedSchools, school, recordNumber)) {
                    currentSchool = school;
                } else {
                    // no point in continuing processing since we don't have a current school
                    continue;
                }
            }

            //Validate the School, Group, and Year
            final String schoolGroupYear = school + group + String.valueOf(schoolYear);
            if (currentSchoolGroupYear == null || !currentSchoolGroupYear.equalsIgnoreCase(schoolGroupYear)) {
                if (currentSchoolGroupYear != null) {
                    completedSchoolGroupYears.add(currentSchoolGroupYear);
                }
                currentSchoolGroupYearSubject = null;
                currentSchoolGroupYear = schoolGroupYear;

                validateStudentCount(failures, currentSchool, currentGroup, studentCountPerGroup, recordNumber - 1);
                studentCountPerGroup = 0;
                currentGroup = group;
                groupCountPerSchool++;

                validateSchoolGroupYear(failures, completedSchoolGroupYears, schoolGroupYear, recordNumber);
            }

            //Validate the continuity of the Subject
            if (currentSchoolGroupYearSubject == null) {
                currentSchoolGroupYearSubject = subject;
            } else if (subject != null && !subject.equalsIgnoreCase(currentSchoolGroupYearSubject)) {
                addUniqueFailure(failures, recordNumber, "Record is attempting to re-define group subject from ["
                        + currentSchoolGroupYearSubject + "] to [" + subject + "]");

                currentSchoolGroupYearSubject = subject;
            }

            //Count students
            if (isNotBlank(record.get(HeaderSSID))) {
                studentCountPerGroup++;
            }
        }

        validateStudentCount(failures, currentSchool, currentGroup, studentCountPerGroup, recordNumber);

        if (failures.isEmpty()) {
            successes.add(success(recordNumber, groupCountPerSchool, currentSchool));
            return ImmutableList.copyOf(successes);
        }

        return ImmutableList.copyOf(failures);
    }

    private Integer getAsInt(final CSVRecord row, final String header) {
        try {
            return Integer.valueOf(row.get(header));
        } catch (final NumberFormatException e) {
            return null;
        }
    }

    private static boolean validateKeyValues(final List<CsvValidationResult> failures,
                                             final String school,
                                             final String group,
                                             final Integer schoolYear,
                                             final long recordNumber) {
        boolean failure = false;

        if (isBlank(school)) {
            failures.add(failure(recordNumber, "Record does not contain a school"));
            failure = true;
        }
        if (isBlank(group)) {
            failures.add(failure(recordNumber, "Record does not contain a group name"));
            failure = true;
        }
        if (schoolYear == null) {
            failures.add(failure(recordNumber, "Record does not contain a school year"));
            failure = true;
        }

        return !failure;
    }

    private static boolean validateSchool(final List<CsvValidationResult> failures,
                                          final Set<String> schoolIds,
                                          final Set<String> completedSchools,
                                          final String school,
                                          final long recordNumber) {
        boolean failure = false;

        if (!schoolIds.contains(school)) {
            addUniqueFailure(failures, recordNumber, "School [" + school + "] can not be found");
            failure = true;
        }
        if (completedSchools.contains(school)) {
            addUniqueFailure(failures, recordNumber, "School [" + school + "] is out-of-order: sort CSV by school, group, year");
            failure = true;
        }

        return !failure;
    }

    private static void validateStudentCount(final List<CsvValidationResult> failures,
                                             final String school,
                                             final String group,
                                             final int studentCount,
                                             final long recordNumber) {
        if (studentCount > MaxStudentsPerGroup) {
            addUniqueFailure(failures, recordNumber,
                    "School [" + school + "] Group [" + group + "] contains "
                            + studentCount + " students.  Maximum students allowed per group is " + MaxStudentsPerGroup);
        }
    }

    private static void validateSchoolGroupYear(final List<CsvValidationResult> failures,
                                                final Set<String> completedSchoolGroupYears,
                                                final String schoolGroupYear,
                                                final long recordNumber) {
        if (completedSchoolGroupYears.contains(schoolGroupYear)) {
            addUniqueFailure(failures, recordNumber, "Record is out-of-order: sort CSV by school, group, year");
        }
    }

    private static void addUniqueFailure(final List<CsvValidationResult> failures, final long recordNumber, final String message) {
        for (final CsvValidationResult failure : failures) {
            if (failure.getMessage().equals(message)) return;
        }
        failures.add(failure(recordNumber, message));
    }

    private static CsvValidationResult success(final long recordNumber, final int groupCount, final String schoolId) {
        return CsvValidationResult.success(recordNumber,
                String.format(ValidationSuccessFormat, groupCount, groupCount == 1 ? "" : "s", schoolId));
    }

    private static String toMessage(final List<CsvValidationResult> results,
                                    final String messageFormat,
                                    final String moreMessagesFormat) {
        final StringJoiner joiner = new StringJoiner("\n");
        final List<CsvValidationResult> subList = results.size() < MaxMessages ? results : results.subList(0, MaxMessages);
        for (final CsvValidationResult validationResult : subList) {
            joiner.add(String.format(messageFormat, validationResult.getRow(), validationResult.getMessage()));
        }
        if (results.size() > MaxMessages) {
            joiner.add(String.format(moreMessagesFormat, results.size() - MaxMessages));
        }
        return joiner.toString();
    }
}
