package org.opentestsystem.rdw.group;

import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVPrinter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.net.URI;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static com.google.common.collect.Lists.newArrayList;
import static org.opentestsystem.rdw.group.DefaultCsvValidationService.HeaderGroup;
import static org.opentestsystem.rdw.group.DefaultCsvValidationService.HeaderSSID;
import static org.opentestsystem.rdw.group.DefaultCsvValidationService.HeaderSchool;
import static org.opentestsystem.rdw.group.DefaultCsvValidationService.HeaderSubject;
import static org.opentestsystem.rdw.group.DefaultCsvValidationService.HeaderUser;
import static org.opentestsystem.rdw.group.DefaultCsvValidationService.HeaderYear;
import static org.opentestsystem.rdw.group.DefaultCsvValidationService.RequiredHeaders;

/**
 * This testing utility class can be used to generate arbitrarily-large CSV sample files.
 * Replace the school ids list with valid values from your local database.
 */
public class CsvGenerator {
    private static final Logger logger = LoggerFactory.getLogger(CsvGenerator.class);

    private static final int NumGroupsPerSchool = 1000; //4500
    private static final int NumStudentsPerGroup = 30;
    private static final String output = "file:///tmp/output.csv";
    private static final List<String> SchoolIds = newArrayList(
            "88800120012001",
            "88800120012002",
            "88800120012003",
            "88800120012004",
            "88800130013001",
            "88800130013002",
            "88800130013003",
            "88800130013004",
            "88800130013005"
    );

    private static final String GroupPrefix = "Group_";

    public static void main(final String[] args) throws Exception {

        final URI uri = URI.create(output);
        final File file = new File(uri);
        if (!file.createNewFile()) {
            throw new IllegalStateException("Unable to create output file");
        }

        final CSVFormat format = CSVFormat.DEFAULT
                .withFirstRecordAsHeader()
                .withSkipHeaderRecord(false)
                .withHeader(RequiredHeaders.toArray(new String[0]));
        final Map<String, String> recordValues = new HashMap<>();
        recordValues.put(HeaderYear, "2017");

        try (final CSVPrinter printer = new CSVPrinter(new FileWriter(file), format)) {

            for (final String schoolId : SchoolIds) {
                logger.info("Starting school: {}", schoolId);
                recordValues.put(HeaderSchool, schoolId);

                int groupCount = NumGroupsPerSchool;
                while (groupCount >= 0) {
                    final String groupId = GroupPrefix + groupCount--;
                    recordValues.put(HeaderGroup, groupId);

                    //add subject row
                    recordValues.put(HeaderSubject, "ELA");
                    printRow(printer, recordValues);
                    recordValues.remove(HeaderSubject);

                    //add teacher row
                    recordValues.put(HeaderUser, "teacher@somewhere.com");
                    printRow(printer, recordValues);
                    recordValues.remove(HeaderUser);

                    //add students
                    int studentCount = NumStudentsPerGroup;
                    while (studentCount >= 0) {
                        recordValues.put(HeaderSSID, schoolId + groupId + "_" + studentCount--);
                        printRow(printer, recordValues);
                    }
                    recordValues.remove(HeaderSSID);
                }
            }
        }
    }

    private static void printRow(final CSVPrinter printer, final Map<String, String> row) throws IOException {
        final List<String> values = new ArrayList<>(RequiredHeaders.size());
        for (final String header : RequiredHeaders) {
            values.add(row.get(header));
        }
        printer.printRecord(values);
    }

}
