package org.opentestsystem.rdw.group;

import com.google.common.base.Joiner;
import com.google.common.collect.ImmutableSet;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVParser;
import org.apache.commons.csv.CSVPrinter;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;
import org.opentestsystem.rdw.security.PermissionScope;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.StringReader;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import static com.google.common.collect.Lists.newArrayList;
import static com.google.common.collect.Lists.newLinkedList;
import static com.google.common.collect.Maps.newHashMap;
import static com.google.common.collect.Sets.newHashSet;
import static java.nio.charset.StandardCharsets.UTF_8;
import static org.apache.commons.lang3.StringUtils.EMPTY;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.when;
import static org.opentestsystem.rdw.group.DefaultCsvValidationService.HeaderGroup;
import static org.opentestsystem.rdw.group.DefaultCsvValidationService.HeaderSSID;
import static org.opentestsystem.rdw.group.DefaultCsvValidationService.HeaderSchool;
import static org.opentestsystem.rdw.group.DefaultCsvValidationService.HeaderSubject;
import static org.opentestsystem.rdw.group.DefaultCsvValidationService.HeaderYear;
import static org.opentestsystem.rdw.group.DefaultCsvValidationService.MaxStudentsPerGroup;
import static org.opentestsystem.rdw.group.DefaultCsvValidationService.RequiredHeaders;

@RunWith(MockitoJUnitRunner.class)
public class DefaultCsvValidationServiceTest {
    private static final String SchoolA = "SCHOOL_A";
    private static final String SchoolB = "SCHOOL_B";
    private static final String GroupA = "GROUP_A";
    private static final String GroupB = "GROUP_B";
    private static final int SchoolYear = 2017;

    @Mock
    private SchoolRepository schoolRepository;
    @Mock
    private SchoolYearRepository schoolYearRepository;
    @Mock
    private SubjectRepository subjectRepository;

    private DefaultCsvValidationService service;

    @Before
    public void setup() {
        when(schoolRepository.findAllNaturalIds(PermissionScope.STATEWIDE)).thenReturn(ImmutableSet.of(SchoolA, SchoolB));
        when(schoolYearRepository.findAll()).thenReturn(newArrayList(2016, 2017, 2018));
        when(subjectRepository.findAllCodes()).thenReturn(newHashSet("Math", "ELA"));

        service = new DefaultCsvValidationService(schoolRepository, schoolYearRepository, subjectRepository);
    }

    @Test
    public void itShouldValidateASimpleGroupFile() {
        final String csv = recordBuilder()
                .row(SchoolA, GroupA)
                .row(SchoolA, GroupB, SchoolYear, "ELA", null)
                .row(SchoolA, GroupB, SchoolYear, "ELA", null)
                .row(SchoolB, GroupB)
                .row(SchoolB, GroupB)
                .build();

        final Map<String,String> fileProperties = newHashMap();
        final List<CsvValidationResult> results = service.validate(new ByteArrayInputStream(csv.getBytes(UTF_8)), PermissionScope.STATEWIDE, fileProperties);

        assertThat(results).hasSize(2);
        assertThat(results.stream().filter(r -> !r.isOk()).collect(Collectors.toList())).isEmpty();
        assertThat(fileProperties.get("newline")).isEqualTo("\\r\\n");
        assertThat(fileProperties.get("delimiter")).isEqualTo(",");
    }

    @Test
    public void itShouldValidateRequiredHeaders() {
        assertThat(service.validateHeaders(RequiredHeaders)).isEmpty();
    }

    @Test
    public void itShouldNotValidateMissingHeaders() {
        final List<String> missingHeaders = newArrayList(RequiredHeaders);
        missingHeaders.remove(0);

        final CsvValidationResult failure = service.validateHeaders(missingHeaders).get(0);

        assertThat(failure.getRow()).isEqualTo(0);
        assertThat(failure.getMessage()).contains(Joiner.on(",").join(RequiredHeaders));
    }

    @Test
    public void itShouldNotValidateOutOfOrderHeaders() {
        final List<String> misOrderedHeaders = newLinkedList(RequiredHeaders);
        misOrderedHeaders.add(misOrderedHeaders.remove(0));

        final CsvValidationResult failure = service.validateHeaders(misOrderedHeaders).get(0);

        assertThat(failure.getRow()).isEqualTo(0);
        assertThat(failure.getMessage()).contains(Joiner.on(",").join(RequiredHeaders));
    }

    @Test
    public void itShouldNotValidateUnknownSchoolYear() throws IOException {
        final RecordBuilder builder = recordBuilder()
                .row(SchoolA, "Good Year", 2016, null, null)
                .row(SchoolA, "Bad Year 1718-A", 1718, null, null)
                .row(SchoolA, "Bad Year 1718-B", 1718, null, null)
                .row(SchoolA, "Bad Year 1964", 1964, null, null);

        try (final CSVParser parser = builder.buildAndParse()) {
            final List<CsvValidationResult> failures = service.validateRecords(parser.iterator(), PermissionScope.STATEWIDE);

            assertThat(failures).hasSize(2);
            assertThat(failures.get(0).getRow()).isEqualTo(2);
            assertThat(failures.get(0).getMessage()).contains("Invalid school year: 1718");
            assertThat(failures.get(1).getRow()).isEqualTo(4);
            assertThat(failures.get(1).getMessage()).contains("Invalid school year: 1964");
        }
    }

    @Test
    public void itShouldValidateACsvWithSchoolsAndGroupsInOrder() throws Exception {
        final RecordBuilder builder = recordBuilder()
                .row(SchoolA, GroupA)
                .row(SchoolA, GroupB)
                .row(SchoolB, GroupB)
                .row(SchoolB, GroupB);

        try (final CSVParser parser = builder.buildAndParse()) {
            final List<CsvValidationResult> results = service.validateRecords(parser.iterator(), PermissionScope.STATEWIDE);

            assertThat(results).hasSize(2);
            assertThat(results.get(0).getMessage()).isEqualTo("2 groups accepted for SCHOOL_A.");
            assertThat(results.get(1).getMessage()).isEqualTo("1 group accepted for SCHOOL_B.");
        }
    }

    @Test
    public void itShouldNotValidateACsvWithSchoolsOutOfOrder() throws Exception {
        final RecordBuilder builder = recordBuilder()
                .row(SchoolA, GroupA)
                .row(SchoolB, GroupB)
                .row(SchoolB, GroupB)
                .row(SchoolA, GroupB);

        try (final CSVParser parser = builder.buildAndParse()) {
            final List<CsvValidationResult> failures = service.validateRecords(parser.iterator(), PermissionScope.STATEWIDE);

            assertThat(failures).hasSize(1);
            assertThat(failures.get(0).getRow()).isEqualTo(4);
            assertThat(failures.get(0).getMessage()).contains("out-of-order");
        }
    }

    @Test
    public void itShouldNotValidateACsvWithGroupsOutOfOrder() throws Exception {
        final RecordBuilder builder = recordBuilder()
                .row(SchoolA, GroupA)
                .row(SchoolA, GroupB)
                .row(SchoolA, GroupA)
                .row(SchoolB, GroupB)
                .row(SchoolB, GroupB);

        try (final CSVParser parser = builder.buildAndParse()) {
            final List<CsvValidationResult> failures = service.validateRecords(parser.iterator(), PermissionScope.STATEWIDE);

            assertThat(failures).hasSize(1);
            assertThat(failures.get(0).getRow()).isEqualTo(3);
            assertThat(failures.get(0).getMessage()).contains("out-of-order");
        }
    }

    @Test
    public void itShouldNotValidateACsvWithAMissingGroupsPrimaryKeyRecord() throws Exception {
        final RecordBuilder builder = recordBuilder()
                .row(SchoolA, GroupA)
                .row(SchoolA, EMPTY)
                .row(SchoolB, GroupB)
                .row(SchoolB, GroupB);

        try (final CSVParser parser = builder.buildAndParse()) {
            final List<CsvValidationResult> failures = service.validateRecords(parser.iterator(), PermissionScope.STATEWIDE);

            assertThat(failures).hasSize(1);
            assertThat(failures.get(0).getRow()).isEqualTo(2);
            assertThat(failures.get(0).getMessage()).contains("group name");
        }
    }

    @Test
    public void itShouldNotValidateACsvWithAnUnknownOrUnauthorizedSchool() throws Exception {
        final RecordBuilder builder = recordBuilder()
                .row("UnknownSchool", GroupA)
                .row(SchoolA, GroupB)
                .row(SchoolB, GroupB)
                .row(SchoolB, GroupB);

        try (final CSVParser parser = builder.buildAndParse()) {
            final List<CsvValidationResult> failures = service.validateRecords(parser.iterator(), PermissionScope.STATEWIDE);

            assertThat(failures).hasSize(1);
            assertThat(failures.get(0).getRow()).isEqualTo(1);
            assertThat(failures.get(0).getMessage()).contains("UnknownSchool");
        }
    }

    @Test
    public void itShouldNotValidateACsvWithMultipleGroupSubjects() throws Exception {
        final RecordBuilder builder = recordBuilder()
                .row(SchoolA, GroupA)
                .row(SchoolA, GroupB, SchoolYear, "ELA", null)
                .row(SchoolA, GroupB, SchoolYear, "Math", null)
                .row(SchoolB, GroupB)
                .row(SchoolB, GroupB);

        try (final CSVParser parser = builder.buildAndParse()) {
            final List<CsvValidationResult> failures = service
                    .validateRecords(parser.iterator(), PermissionScope.STATEWIDE);

            assertThat(failures).hasSize(1);
            assertThat(failures.get(0).getRow()).isEqualTo(3);
            assertThat(failures.get(0).getMessage()).contains("[ELA]", "[Math]");
        }
    }

    @Test
    public void itShouldNotValidateACsvWithMoreThanMaxStudentsPerGroup() throws Exception {
        final RecordBuilder builder = recordBuilder();
        for (int i = 0; i < (MaxStudentsPerGroup + 1); i++) {
            builder.row(SchoolA, GroupA, SchoolYear, "ELA", "Student_" + i);
        }

        try (final CSVParser parser = builder.buildAndParse()) {
            final List<CsvValidationResult> failures = service
                    .validateRecords(parser.iterator(), PermissionScope.STATEWIDE);

            assertThat(failures).hasSize(1);
            assertThat(failures.get(0).getRow()).isEqualTo(MaxStudentsPerGroup + 1);
            assertThat(failures.get(0).getMessage()).contains("Maximum students allowed");
        }
    }

    @Test
    public void itShouldFormatFailureMessages() {
        final List<CsvValidationResult> results = newArrayList();
        results.add(CsvValidationResult.failure(1, "failure 1"));
        results.add(CsvValidationResult.failure(2, "failure 2"));

        assertThat(service.toFailureMessage(results))
                .contains("Row: 1 Failure: failure 1")
                .contains("Row: 2 Failure: failure 2");
    }

    @Test
    public void itShouldTruncateLotsOfFailureMessages() {
        final List<CsvValidationResult> results = newArrayList();
        for (int i = 1; i <= 200; ++i) {
            results.add(CsvValidationResult.failure(i, "failure " + i));
        }

        assertThat(service.toFailureMessage(results))
                .contains("Row: 1 Failure: failure 1")
                .contains("Row: 100 Failure: failure 100")
                .contains("With 100 additional validation failures");
    }

    @Test
    public void itShouldHandleEdgeCase() {
        final List<CsvValidationResult> results = newArrayList();
        for (int i = 1; i <= 100; ++i) {
            results.add(CsvValidationResult.failure(i, "failure " + i));
        }

        assertThat(service.toFailureMessage(results))
                .contains("Row: 1 Failure: failure 1")
                .contains("Row: 100 Failure: failure 100");
    }

    @Test
    public void itShouldHandleZeroResults() {
        assertThat(service.toFailureMessage(newArrayList())).isEqualTo("");
    }

    @Test
    public void itShouldFormatSuccessMessages() {
        final List<CsvValidationResult> results = newArrayList();
        results.add(CsvValidationResult.success(0, "all good"));
        results.add(CsvValidationResult.success(42, "lots of things processed"));

        assertThat(service.toSuccessMessage(results))
                .contains("all good")
                .contains("lots of things processed")
                .doesNotContain("42");
    }

    @Test
    public void itShouldTruncateLotsOfSuccessMessages() {
        final List<CsvValidationResult> results = newArrayList();
        for (int i = 1; i <= 200; ++i) {
            results.add(CsvValidationResult.success(i, "success " + i));
        }

        assertThat(service.toSuccessMessage(results))
                .contains("success 1")
                .contains("success 100")
                .doesNotContain("success 101")
                .contains("With 100 additional");
    }

    @Test
    public void itWillFormatSuccessesAsFailures() {
        // just demonstrating a quirk of how this is set up
        final List<CsvValidationResult> results = newArrayList();
        results.add(CsvValidationResult.success(0, "all good"));
        results.add(CsvValidationResult.success(42, "lots of things processed"));

        assertThat(service.toFailureMessage(results))
                .contains("Row: 0 Failure: all good")
                .contains("Row: 42 Failure: lots of things processed");
    }

    private static RecordBuilder recordBuilder() {
        return new RecordBuilder();
    }

    private static class RecordBuilder {
        final List<List<String>> records = newArrayList();

        private static final CSVFormat format = CSVFormat.DEFAULT
                .withIgnoreHeaderCase()
                .withFirstRecordAsHeader()
                .withHeader(RequiredHeaders.toArray(new String[0]));

        String build() {
            try {
                final StringBuilder csvBuilder = new StringBuilder();
                final CSVPrinter printer = new CSVPrinter(csvBuilder, format.withSkipHeaderRecord(false));
                for (final List<String> record : records) {
                    printer.printRecord(record);
                }
                printer.close();

                return csvBuilder.toString();
            } catch (final IOException e) {
                throw new RuntimeException(e);
            }
        }

        // useful for testing helper methods
        CSVParser buildAndParse() {
            try {
                return new CSVParser(new StringReader(build()), format);
            } catch (final IOException e) {
                throw new RuntimeException(e);
            }
        }

        RecordBuilder row(final String school, final String group) {
            return row(school, group, SchoolYear, null, null);
        }

        RecordBuilder row(final String school,
                          final String group,
                          final int schoolYear,
                          final String subject,
                          final String studentSSID) {
            final Map<String, String> record = new HashMap<>();
            record.put(HeaderSchool, school);
            record.put(HeaderGroup, group);
            record.put(HeaderYear, String.valueOf(schoolYear));
            record.put(HeaderSubject, subject);
            record.put(HeaderSSID, studentSSID);

            final List<String> values = newArrayList();
            for (final String header : RequiredHeaders) {
                values.add(record.get(header));
            }
            records.add(values);

            return this;
        }
    }
}