package org.opentestsystem.rdw.common.model.assessment;

import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVParser;
import org.apache.commons.csv.CSVRecord;
import org.apache.commons.io.input.BOMInputStream;
import org.opentestsystem.rdw.common.model.AssessmentType;

import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.nio.charset.StandardCharsets;
import java.util.Collection;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

import static com.google.common.collect.Lists.newArrayList;
import static java.lang.Double.parseDouble;
import static org.apache.commons.lang3.StringUtils.isBlank;
import static org.apache.commons.lang3.StringUtils.isNotBlank;
import static org.apache.commons.lang3.StringUtils.trimToNull;

/**
 * Assessment serialization from tabulator CSV.
 */
public class TabulatorService implements AssessmentSerializationService {
    // main assessment columns
    private static final String AssessmentId = "AssessmentId";
    private static final String AssessmentName = "AssessmentName";
    private static final String AssessmentLabel = "AssessmentLabel";
    private static final String AssessmentSubject = "AssessmentSubject";
    private static final String AssessmentSubtype = "AssessmentSubtype";
    private static final String AssessmentGrade = "AssessmentGrade";
    private static final String AcademicYear = "AcademicYear";

    private static final String FullItemKey = "FullItemKey";

    private static final int MaxOverallLevels = 6;
    private static final int MaxAltScorings = 6;
    private static final int MaxAltLevels = 6;

    private static Collection<String> RequiredColumns = newArrayList(
            AssessmentId,
            AssessmentName,
            AssessmentLabel,
            AssessmentSubject,
            AssessmentGrade,
            AssessmentSubtype,
            AcademicYear
    );

    /**
     * @param inputStream input stream of tabulator CSV content
     * @return list of assessments
     * @throws IllegalArgumentException if any problem parsing content
     */
    @Override
    public List<Assessment> parse(final InputStream inputStream) {

        try (final Reader reader = new InputStreamReader(new BOMInputStream(inputStream), StandardCharsets.UTF_8)) {
            final CSVParser csvParser = CSVFormat.RFC4180
                    .withFirstRecordAsHeader()
                    .withCommentMarker('#')
                    .parse(reader);

            final ParseState helper = new ParseState();
            helper.validateHeaders(csvParser.getHeaderMap().keySet());

            final Iterator<CSVRecord> recordIterator = csvParser.iterator();
            if (!recordIterator.hasNext()) return newArrayList();

            while(recordIterator.hasNext()) {
                try {
                    helper.parse(recordIterator.next());
                } catch (final IllegalArgumentException e) {
                    // enhance the error message with the record number
                    final String message = "Error (record=" + csvParser.getRecordNumber() +
                            ", line=" + csvParser.getCurrentLineNumber() + "): " + e.getMessage();
                    throw new IllegalArgumentException(message);
                }
            }
            return helper.getAssessments();

        } catch (final IOException ioe) {
            throw new IllegalArgumentException("Error reading content", ioe);
        }
    }


    private static class ParseState {
        // use a linked hash map so order is preserved
        private Map<String, Assessment.ValidatingBuilder> builders = new LinkedHashMap<>();
        private String overallScorePrefix;
        private boolean hasAltScoreHeaders;
        private boolean hasItemHeaders;
        private String passageHeader;

        private List<Assessment> getAssessments() {
            return builders.values().stream().map(Assessment.ValidatingBuilder::build).collect(Collectors.toList());
        }

        private void validateHeaders(final Set<String> headers) {
            if (!headers.containsAll(RequiredColumns)) {
                final List<String> missing = newArrayList(RequiredColumns);
                missing.removeAll(headers);
                throw new IllegalArgumentException("Missing required columns: " + missing.toString());
            }

            // overall score columns are either like "ScaledLow1" or "OverallLow1"
            if (headers.contains("ScaledLow1")) {
                overallScorePrefix = "Scaled";
            } else if (headers.contains("OverallLow1")) {
                overallScorePrefix = "Overall";
            } else {
                throw new IllegalArgumentException("Overall scale score column not found");
            }

            // alt scores are a new thing, set a flag to control parsing for them
            hasAltScoreHeaders = headers.contains("Alt1Low1");

            // assessments don't have to provide item info if test results won't have item detail
            hasItemHeaders = headers.contains(FullItemKey);

            // legacy content had a different header for passage column
            passageHeader = headers.contains("PassageRef") ? "PassageRef" : "PassageId";
        }

        private void parse(final CSVRecord record) {
            final String id = toString(record.get(AssessmentId));
            if (id == null) {
                // if the row is completely empty we can just ignore it
                if (emptyRow(record)) {
                    return;
                }
                // but if the id column is empty and there is other data in the row, that's bad
                else {
                    throw new IllegalArgumentException("Missing assessment id in non-empty row");
                }
            }

            final Assessment.ValidatingBuilder builder = builders.computeIfAbsent(id, i -> Assessment.builder().id(i));
            builder.name(toString(record.get(AssessmentName)))
                    .label(toString(record.get(AssessmentLabel)))
                    .subject(toString(record.get(AssessmentSubject)))
                    .type(toAssessmentType(toString(record.get(AssessmentSubtype))))
                    .grade(toString(record.get(AssessmentGrade)))
                    .schoolYear(toSchoolYear(toString(record.get(AcademicYear))))
                    .version(toString(record.get("AssessmentVersion")))
                    .overallScoring(parseOverallScoring(record))
                    .altScorings(parseAltScoring(record))
                    .item(parseItem(record))
                    ;
        }

        /**
         * Helper to parse overall scoring columns.
         * Always returns a non-null scoring or throws.
         *
         * @param record record to parse
         * @return overall scoring
         * @throws IllegalArgumentException if there isn't at least one level
         * @throws NumberFormatException if level low/high aren't decimal numbers
         */
        private Scoring parseOverallScoring(final CSVRecord record) {
            final Scoring.Builder builder = Scoring.builder();
            for (int level = 1; level <= MaxOverallLevels; ++level) {
                final String lowName = overallScorePrefix + "Low" + level;
                if (!hasValue(record, lowName)) {
                    break;
                }
                final double low = parseDouble(record.get(lowName));

                // deal with legacy files that have just "Low" values for some levels
                final double high;
                final String highName = overallScorePrefix + "High" + level;
                if (hasValue(record, highName)) {
                    high = parseDouble(record.get(highName));
                } else {
                    final String nextLowName = overallScorePrefix + "Low" + (level+1);
                    if (hasValue(record, nextLowName)) {
                        high = parseDouble(record.get(nextLowName));
                    } else {
                        throw new IllegalArgumentException("Missing high score level");
                    }
                }

                builder.levelRange(low, high);
            }
            final Scoring scoring = builder.build();
            if (scoring.getLevelCount() == 0) {
                throw new IllegalArgumentException("At least one overall scoring level must be set");
            }
            return scoring;
        }

        /**
         * Helper to parse alt scoring columns.
         * May return null if alt scoring values aren't present.
         *
         * @param record record to parse
         * @return list of alt scorings, may be null, won't be empty
         * @throws NumberFormatException if level low/high aren't decimal numbers
         */
        private List<Scoring> parseAltScoring(final CSVRecord record) {
            if (!hasAltScoreHeaders) return null;

            final List<Scoring> scorings = newArrayList();
            for (int alt = 1; alt < MaxAltScorings; ++alt) {
                final Scoring.Builder builder = Scoring.builder();
                for (int level = 1; level < MaxAltLevels; ++level) {
                    final String low = "Alt" + alt + "Low" + level;
                    if (!hasValue(record, low)) {
                        break;
                    }
                    builder.levelRange(parseDouble(record.get(low)),
                                       parseDouble(record.get("Alt" + alt + "High" + level)));
                }
                if (!builder.isEmpty()) {
                    scorings.add(builder.build());
                }
            }
            return scorings.isEmpty() ? null : scorings;
        }

        /**
         * Helper to parse item columns.
         *
         * @param record record to parse
         * @return item or null if item column values aren't present
         * @throws IllegalArgumentException for any invalid data types
         */
        private Item parseItem(final CSVRecord record) {
            if (!hasItemHeaders) return null;

            return Item.builder()
                    .fullKey(toString(record.get(FullItemKey)))
                    .bankKey(toString(record.get("BankKey")))
                    .itemId(toString(record.get("ItemId")))
                    .filename(toString(record.get("Filename")))
                    .version(toString(record.get("Version")))
                    .type(toString(record.get("ItemType")))
                    .grade(toString(record.get("Grade")))
                    .standard(toString(record.get("Standard")))
                    .claim(toString(record.get("Claim")))
                    .target(toString(record.get("Target")))
                    .claimContentTarget(toString(record.get("ClaimContentTarget")))
                    .secondaryClaimContentTarget(toString(record.get("SecondaryClaimContentTarget")))
                    .commonCore(toString(record.get("CommonCore")))
                    .secondaryCommonCore(toString(record.get("SecondaryCommonCore")))
                    .asl(toBoolean(record.get("ASL")))
                    .braille(toString(record.get("Braille")))
                    .brailleLanguage(toString(record.get("LanguageBraille")))
                    .dok(toInteger(record.get("DOK")))
                    .language(toString(record.get("Language")))
                    .allowCalculator(toBoolean(record.get("AllowCalculator")))
                    .mathPractice(toBoolean(record.get("MathematicalPractice")))
                    .maxPoints(toInteger(record.get("MaxPoints")))
                    .glossary(toString(record.get("Glossary")))
                    .scoringEngine(toString(record.get("ScoringEngine")))
                    .spanish(toBoolean(record.get("Spanish")))
                    .fieldTest(toBoolean(record.get("IsFieldTest")))
                    .active(toBoolean(record.get("IsActive")))
                    .responseRequired(toBoolean(record.get("ResponseRequired")))
                    .adminRequired(toBoolean(record.get("AdminRequired")))
                    .position(toInteger(record.get("ItemPosition")))
                    .measurementModel(toString(record.get("MeasurementModel")))
                    .weight(toInteger(record.get("Weight")))
                    .scorePoints(toInteger(record.get("ScorePoints")))
                    .a(toDouble(record.get("a")))
                    .b0_b(toDouble(record.get("b0_b")))
                    .b1_c(toDouble(record.get("b1_c")))
                    .b2(toDouble(record.get("b2")))
                    .b3(toDouble(record.get("b3")))
                    .avg_b(toDouble(record.get("avg_b")))
                    .bpref1(toString(record.get("bpref1")))
                    .bpref2(toString(record.get("bpref2")))
                    .bpref3(toString(record.get("bpref3")))
                    .bpref4(toString(record.get("bpref4")))
                    .bpref5(toString(record.get("bpref5")))
                    .bpref6(toString(record.get("bpref6")))
                    .bpref7(toString(record.get("bpref7")))

                    // legacy content has been seen that doesn't have these columns so allow them to be missing
                    .passage(toString(getOptional(record, passageHeader)))

                    // these columns were added recently so allow them to be missing
                    .answerKey(toString(getOptional(record, "AnswerKey")))
                    .numberOfAnswerOptions(toInteger(getOptional(record, "NumberOfAnswerOptions")))
                    .performanceTask(toBoolean(getOptional(record, "PerformanceTask")))
                    .ptWritingType(toString(getOptional(record, "PtWritingType")))

                    .build();
        }

        /**
         * Helper to deal with columns we know may not exist in older content.
         * This is NOT the same as a column that has to exist but may have no value.
         *
         * @param record record being parsed
         * @param name column name
         * @return value from column or null if column doesn't exist
         */
        private static String getOptional(final CSVRecord record, final String name) {
            return record.isMapped(name) ? record.get(name) : null;
        }

        private static String toString(final String rawValue) {
            return trimToNull(rawValue);
        }

        private static Boolean toBoolean(final String rawValue) {
            final String value = trimToNull(rawValue);
            if (value == null) return null;
            if (value.equalsIgnoreCase("Y") || value.equalsIgnoreCase("TRUE")) return true;
            if (value.equalsIgnoreCase("N") || value.equalsIgnoreCase("FALSE")) return false;
            throw new IllegalArgumentException("Invalid boolean value " + value);
        }

        private static Integer toInteger(final String rawValue) {
            final String value = trimToNull(rawValue);
            return value == null ? null : Integer.valueOf(value);
        }

        private static Double toDouble(final String rawValue) {
            final String value = trimToNull(rawValue);
            return value == null ? null : Double.valueOf(value);
        }

        private static AssessmentType toAssessmentType(final String subtype) {
            if (isBlank(subtype)) return null;
            return AssessmentType.fromCode("summative".equalsIgnoreCase(subtype) ? "sum" : subtype.toLowerCase());
        }

        private static Integer toSchoolYear(final String value) {
            if (isBlank(value)) return null;
            // if the value has a hyphen then split and return the last value, e.g. 2016-2017
            // otherwise just return the value ...
            final String[] split = value.split("-");
            return Integer.valueOf(split.length == 0 ? value : split[split.length - 1]);
        }

        private static boolean emptyRow(final CSVRecord record) {
            for (final String value : record) {
                if (trimToNull(value) != null) return false;
            }
            return true;
        }

        private static boolean hasValue(final CSVRecord record, final String name) {
            try {
                return record.isSet(name) && isNotBlank(record.get(name));
            } catch (final IllegalArgumentException ignored) {
                return false;
            }
        }
    }
}
