package org.opentestsystem.rdw.common.model.subject;

import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.dataformat.xml.XmlMapper;
import com.google.common.io.Resources;
import org.codehaus.stax2.XMLInputFactory2;
import org.codehaus.stax2.XMLStreamReader2;
import org.codehaus.stax2.validation.XMLValidationSchema;
import org.codehaus.stax2.validation.XMLValidationSchemaFactory;
import org.opentestsystem.rdw.common.model.subject.jackson.SubjectModule;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.StringWriter;

/**
 * Utility class providing de/serialization methods for converting a Subject
 * to/from XML.
 */
public abstract class SubjectXmlUtils {
    private static final Logger logger = LoggerFactory.getLogger(SubjectXmlUtils.class);
    private static XmlMapper xmlMapper;
    private static XMLValidationSchema subjectSchema;

    /**
     * Parse a Subject from the given XML input stream.
     *
     * @param inputStream   An XML input stream
     * @return  The Subject represented by the given XML
     */
    public static Subject subjectFromXml(final InputStream inputStream) {
        try {
            return getMapper().readValue(getStreamReader(inputStream), Subject.class);
        } catch (final IOException e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * Serialize a Subject to XML.
     *
     * @param subject A Subject model
     * @return  The XML representation of the subject as a string
     */
    public static String subjectToXml(final Subject subject) {
        try(final StringWriter writer = new StringWriter()) {
            getMapper().writeValue(writer, subject);
            return writer.toString();
        } catch (final IOException e) {
            throw new RuntimeException(e);
        }
    }

    private static XMLStreamReader getStreamReader(final InputStream inputStream) {
        final XMLInputFactory2 factory = (XMLInputFactory2) XMLInputFactory2.newFactory();
        try {
            final XMLStreamReader2 reader = (XMLStreamReader2) factory.createXMLStreamReader(inputStream);
            reader.validateAgainst(getSubjectSchema());
            return reader;
        } catch (final XMLStreamException e) {
            logger.warn("Failed to wrap Subject XML input stream as an XMLStreamReader2", e);
            throw new RuntimeException(e);
        }
    }

    private static XMLValidationSchema getSubjectSchema() {
        if (subjectSchema != null) {
            return subjectSchema;
        }

        XMLValidationSchema schema;
        final XMLValidationSchemaFactory schemaFactory = XMLValidationSchemaFactory.newInstance(XMLValidationSchema.SCHEMA_ID_W3C_SCHEMA);
        try(final InputStream xsdData = Resources.getResource("RDW_Subject.xsd").openStream()) {
            schema = schemaFactory.createSchema(xsdData);
        } catch (final IOException | XMLStreamException e) {
            logger.warn("Unable to load Subject XML schema", e);
            schema = null;
        }
        subjectSchema = schema;
        return subjectSchema;
    }

    private static XmlMapper getMapper() {
        if (xmlMapper != null) {
            return xmlMapper;
        }

        final XmlMapper mapper = new XmlMapper();
        mapper.registerModule(new SubjectModule());
        mapper.configure(SerializationFeature.INDENT_OUTPUT, true);
        xmlMapper = mapper;
        return xmlMapper;
    }
}
