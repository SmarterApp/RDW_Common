package org.opentestsystem.rdw.common.model.subject;

import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.dataformat.xml.XmlMapper;
import com.google.common.io.Resources;
import org.codehaus.stax2.XMLInputFactory2;
import org.codehaus.stax2.XMLStreamReader2;
import org.codehaus.stax2.validation.XMLValidationSchema;
import org.codehaus.stax2.validation.XMLValidationSchemaFactory;
import org.opentestsystem.rdw.common.model.subject.jackson.SubjectModule;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.StringWriter;

/**
 * Subject serialization implementation for XML with streaming XSD validation
 */
public class XmlSubjectSerializationService implements SubjectSerializationService {
    private static final Logger logger = LoggerFactory.getLogger(XmlSubjectSerializationService.class);
    private static XmlMapper xmlMapper;
    private static XMLValidationSchema subjectSchema;

    @Override
    public Subject parseSubject(final InputStream inputStream) throws IOException {
        return getMapper().readValue(getStreamReader(inputStream), Subject.class);
    }

    @Override
    public String serializeSubject(final Subject subject) throws IOException {
        try(final StringWriter writer = new StringWriter()) {
            getMapper().writeValue(writer, subject);
            return writer.toString();
        }
    }

    private static XMLStreamReader getStreamReader(final InputStream inputStream) {
        final XMLInputFactory2 factory = (XMLInputFactory2) XMLInputFactory2.newFactory();
        try {
            final XMLStreamReader2 reader = (XMLStreamReader2) factory.createXMLStreamReader(inputStream);
            reader.validateAgainst(getSubjectSchema());
            return reader;
        } catch (final XMLStreamException e) {
            logger.warn("Failed to wrap Subject XML input stream as an XMLStreamReader2", e);
            throw new RuntimeException(e);
        }
    }

    private static XMLValidationSchema getSubjectSchema() {
        if (subjectSchema != null) {
            return subjectSchema;
        }

        XMLValidationSchema schema;
        final XMLValidationSchemaFactory schemaFactory = XMLValidationSchemaFactory.newInstance(XMLValidationSchema.SCHEMA_ID_W3C_SCHEMA);
        try(final InputStream xsdData = Resources.getResource("RDW_Subject.xsd").openStream()) {
            schema = schemaFactory.createSchema(xsdData);
        } catch (final IOException | XMLStreamException e) {
            logger.warn("Unable to load Subject XML schema", e);
            schema = null;
        }
        subjectSchema = schema;
        return subjectSchema;
    }

    private static XmlMapper getMapper() {
        if (xmlMapper != null) {
            return xmlMapper;
        }

        final XmlMapper mapper = new XmlMapper();
        mapper.registerModule(new SubjectModule());
        mapper.configure(SerializationFeature.INDENT_OUTPUT, true);
        xmlMapper = mapper;
        return xmlMapper;
    }
}
