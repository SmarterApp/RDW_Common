package org.opentestsystem.rdw.common.model.subject;

import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.dataformat.xml.XmlMapper;
import org.codehaus.stax2.XMLInputFactory2;
import org.codehaus.stax2.XMLStreamReader2;
import org.codehaus.stax2.validation.XMLValidationSchema;
import org.codehaus.stax2.validation.XMLValidationSchemaFactory;
import org.opentestsystem.rdw.common.model.AssessmentType;
import org.opentestsystem.rdw.common.model.subject.jackson.SubjectModule;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.StringWriter;
import java.util.HashSet;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

/**
 * Subject serialization implementation for XML with streaming XSD validation
 */
public class XmlSubjectSerializationService implements SubjectSerializationService {
    private static final Logger logger = LoggerFactory.getLogger(XmlSubjectSerializationService.class);
    private static final int MaxScorable = 6;

    private static XmlMapper xmlMapper;
    private static XMLValidationSchema subjectSchema;

    @Override
    public Subject parseSubject(final InputStream inputStream) throws IOException {
        final Subject subject = getMapper().readValue(getStreamReader(inputStream), Subject.class);
        setTargetReport(subject);
        setDataOrder(subject);
        return subject;
    }

    @Override
    public String serializeSubject(final Subject subject) throws IOException {
        try(final StringWriter writer = new StringWriter()) {
            getMapper().writeValue(writer, subject);
            return writer.toString();
        }
    }

    private static XMLStreamReader getStreamReader(final InputStream inputStream) {
        final XMLInputFactory2 factory = (XMLInputFactory2) XMLInputFactory2.newFactory();
        try {
            final XMLStreamReader2 reader = (XMLStreamReader2) factory.createXMLStreamReader(inputStream);
            reader.validateAgainst(getSubjectSchema());
            return reader;
        } catch (final XMLStreamException e) {
            logger.warn("Failed to wrap Subject XML input stream as an XMLStreamReader2", e);
            throw new RuntimeException(e);
        }
    }

    private static XMLValidationSchema getSubjectSchema() {
        if (subjectSchema != null) {
            return subjectSchema;
        }

        XMLValidationSchema schema;
        final XMLValidationSchemaFactory schemaFactory = XMLValidationSchemaFactory.newInstance(XMLValidationSchema.SCHEMA_ID_W3C_SCHEMA);
        try(final InputStream xsdData = XmlSubjectSerializationService.class.getResourceAsStream("/RDW_Subject.xsd")) {
            schema = schemaFactory.createSchema(xsdData);
        } catch (final IOException | XMLStreamException e) {
            logger.warn("Unable to load Subject XML schema", e);
            schema = null;
        }
        subjectSchema = schema;
        return subjectSchema;
    }

    private static XmlMapper getMapper() {
        if (xmlMapper != null) {
            return xmlMapper;
        }

        final XmlMapper mapper = new XmlMapper();
        mapper.registerModule(new SubjectModule());
        mapper.configure(SerializationFeature.INDENT_OUTPUT, true);
        xmlMapper = mapper;
        return xmlMapper;
    }

    private static void setTargetReport(final Subject subject) {
        // The desired functionality is an optional attribute with a default value that is an
        // expression depending on the 'code' attribute. Since XSD doesn't support that, this
        // post-processing provides equivalent functionality.
        for (final SubjectAssessmentType subjectAssessmentType : subject.getAssessmentTypes()) {
            if (subjectAssessmentType.isTargetReport() == null) {
                subjectAssessmentType.setTargetReport(subjectAssessmentType.getCode().equals(AssessmentType.SUMMATIVE.code()));
            }
        }
    }

    private static void setDataOrder(final Subject subject) {
        // only set data order on scorable things; i.e. alt-scores and scorable claims
        setDataOrder(subject.getAltScores());
        setDataOrder(subject.getClaims().stream().filter(Claim::isScorable).collect(Collectors.toList()));
    }

    private static void setDataOrder(final List<? extends Scorable> scorables) {
        if (scorables == null || scorables.isEmpty()) return;

        // The desired functionality is an optional attribute with a default value based on the
        // order of the entries. While honoring any assigned values. The data order must be 1..N, N <= 6.
        if (scorables.size() > MaxScorable) {
            throw new IllegalArgumentException("Too many scorables: " + scorables.size());
        }

        final List<Integer> used = scorables.stream().map(Scorable::getDataOrder).filter(Objects::nonNull).collect(Collectors.toList());
        if (!used.isEmpty()) {
            // explicitly assigned data orders must be in the right range and not duplicated
            final List<Integer> tooBig = used.stream().filter(o -> o > scorables.size()).collect(Collectors.toList());
            if (!tooBig.isEmpty()) {
                throw new IllegalArgumentException("Invalid data order: " + tooBig.toString());
            }
            if (used.size() != new HashSet<>(used).size()) {
                throw new IllegalArgumentException("Duplicate data order: " + used.toString());
            }
        }
        final List<Integer> unused = IntStream.rangeClosed(1, scorables.size()).filter(value -> !used.contains(value)).boxed().collect(Collectors.toList());
        for (final Scorable scorable : scorables) {
            if (scorable.getDataOrder() == null) {
                scorable.setDataOrder(unused.remove(0));
            }
        }
    }
}
