package org.opentestsystem.rdw.model;

import javax.xml.bind.annotation.adapters.XmlAdapter;
import java.time.Instant;
import java.time.LocalDateTime;
import java.time.ZoneOffset;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeFormatterBuilder;
import java.time.temporal.TemporalAccessor;

/**
 * An {@link XmlAdapter} for reading xsd:dateTime as an {@link Instant}. If the XML field
 * does not indicate a timezone, assume UTC aka 'Z' aka '+00:00'. It always outputs with
 * the trailing 'Z' indicating UTC.
 * <p>
 * Why this when there are so many clever and confusing adapters out in the interwebs?
 * The XML format as specified allows the xsd:dateTime fields to either specify a time
 * zone using 'Z' or offset ('-07:00'), or to <b>not specify a time zone</b>. None of
 * the built-in parsers or adapters deal with that little twist.
 * </p>
 */
public class InstantXmlAdapter extends XmlAdapter<String, Instant> {

    private final DateTimeFormatter unmarshalFormatter = new DateTimeFormatterBuilder()
        .append(DateTimeFormatter.ISO_LOCAL_DATE_TIME)
        .optionalStart()
            .appendOffset("+HH:MM", "Z")
        .optionalEnd()
        .toFormatter();
    private final DateTimeFormatter marshalFormatter = DateTimeFormatter.ISO_INSTANT;

    @Override
    public Instant unmarshal(final String v) throws Exception {
        if (v == null) return null;

        TemporalAccessor result = unmarshalFormatter.parseBest(v, Instant::from, LocalDateTime::from);
        if (result instanceof LocalDateTime) {
            result = ((LocalDateTime) result).toInstant(ZoneOffset.UTC);
        }
        return (Instant) result;
    }

    @Override
    public String marshal(final Instant v) throws Exception {
        return v == null ? null : marshalFormatter.format(v);
    }
}
