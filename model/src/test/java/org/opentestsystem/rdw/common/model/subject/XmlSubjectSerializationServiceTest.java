package org.opentestsystem.rdw.common.model.subject;

import com.google.common.collect.ImmutableList;
import org.junit.Before;
import org.junit.Test;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.util.Comparator;
import java.util.Map;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

import static java.nio.charset.StandardCharsets.UTF_8;
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.fail;

public class XmlSubjectSerializationServiceTest {

    private AtomicInteger claimIdx;
    private XmlSubjectSerializationService service;

    @Before
    public void setup() {
        claimIdx = new AtomicInteger(1);
        service = new XmlSubjectSerializationService();
    }

    @Test
    public void itShouldSerializeAndDeserializeSubjectAsXML() throws Exception {
        final Subject subject = Subject.builder()
                .code("tst")
                .name("Test")
                .subjectMessages(ImmutableList.of(
                        SubjectMessage.builder()
                                .key("subjectDescription")
                                .value("This column reflects the Common Core State Standard(s) associated with a test item. Test items may be associated with more than one standard.  Items that assess mathematical practices (problem solving, modeling and data analysis, and communicating reasoning) are also aligned to standards that describe the mathematical content with which students engage. For example, an item may ask students to communicate their reasoning when solving a problem about geometry or fractions. For more information, see the <a href=\\\"https://portal.smarterbalanced.org/library/en/mathematics-content-specifications.pd\\\" target=\\\"_blank\\\">Mathematics Content Specifications</a>.")
                                .build()))
                .assessmentTypes(ImmutableList.of(assessmentType("iab", "IAB", false), assessmentType("ica", "ICA", false), assessmentType("sum", "Summative", true)))
                .depthsOfKnowledge(ImmutableList.of(depthOfKnowledge(1), depthOfKnowledge(2), depthOfKnowledge(3)))
                .itemDifficulties(ImmutableList.of(itemDifficulty(1), itemDifficulty(2)))
                .reportGrades(ImmutableList.of(reportGrade("03"), reportGrade("04")))
                .claims(ImmutableList.of(
                        claim("scorable", true, false),
                        claim("org", false, true),
                        claim("both", true, true)))
                .standards(ImmutableList.of(standard("std.0.1"), standard("std.0.2")))
                .build();

        final String xmlValue = service.serializeSubject(subject);
        assertThat(xmlValue).isNotEmpty();

        try(final ByteArrayInputStream input = new ByteArrayInputStream(xmlValue.getBytes(UTF_8))) {
            final Subject deserialized = service.parseSubject(input);
            assertThat(deserialized).usingRecursiveComparison().isEqualTo(subject);
        }
    }

    @Test
    public void itShouldDefaultTargetReportWhenDeserializing() throws Exception {
        final Subject subject = Subject.builder()
                .code("tst")
                .name("Test")
                .subjectMessages(ImmutableList.of(
                        SubjectMessage.builder()
                                .key("subjectDescription")
                                .value("This column reflects the Common Core State Standard(s) associated with a test item. Test items may be associated with more than one standard.  Items that assess mathematical practices (problem solving, modeling and data analysis, and communicating reasoning) are also aligned to standards that describe the mathematical content with which students engage. For example, an item may ask students to communicate their reasoning when solving a problem about geometry or fractions. For more information, see the <a href=\\\"https://portal.smarterbalanced.org/library/en/mathematics-content-specifications.pd\\\" target=\\\"_blank\\\">Mathematics Content Specifications</a>.")
                                .build()))
                .assessmentTypes(ImmutableList.of(assessmentType("iab", "IAB", null), assessmentType("ica", "ICA", null), assessmentType("sum", "Summative", null)))
                .depthsOfKnowledge(ImmutableList.of(depthOfKnowledge(1), depthOfKnowledge(2), depthOfKnowledge(3)))
                .itemDifficulties(ImmutableList.of(itemDifficulty(1), itemDifficulty(2)))
                .reportGrades(ImmutableList.of(reportGrade("03"), reportGrade("04")))
                .claims(ImmutableList.of(
                        claim("scorable", true, false),
                        claim("org", false, true),
                        claim("both", true, true)))
                .standards(ImmutableList.of(standard("std.0.1"), standard("std.0.2")))
                .build();

        final String xmlValue = service.serializeSubject(subject);
        assertThat(xmlValue).isNotEmpty();

        try(final ByteArrayInputStream input = new ByteArrayInputStream(xmlValue.getBytes(UTF_8))) {
            final Subject deserialized = service.parseSubject(input);
            final Map<String, Boolean> map = deserialized.getAssessmentTypes().stream()
                    .collect(Collectors.toMap(SubjectAssessmentType::getCode, SubjectAssessmentType::isTargetReport));
            assertThat(map.get("iab")).isFalse();
            assertThat(map.get("ica")).isFalse();
            assertThat(map.get("sum")).isTrue();
        }
    }

    @Test
    public void itShouldValidateXMLAgainstTheXSD() {
        final String invalidXml = "<Subject code=\"blah\" name=\"Blah\"/>";
        try (final ByteArrayInputStream input = new ByteArrayInputStream(invalidXml.getBytes(UTF_8))) {
            service.parseSubject(input);
        } catch (final IllegalArgumentException e) {
            assertThat(e.getMessage()).contains("uncompleted content model");
        } catch (IOException e) {
            fail("it should've propagated an IAE");
        }
    }

    @Test
    public void itShouldAssignDataOrder() {
        // SOCK_LS has an explicit dataOrder=3, the others have no dataOrder
        try (final InputStream is = this.getClass().getResourceAsStream("/ClaimOrder.xml")) {
            final Subject subject = service.parseSubject(is);
            assertThat(subject.getClaims().stream()
                    .filter(Claim::isScorable)
                    .sorted(Comparator.comparingInt(Claim::getDataOrder))
                    .map(Claim::getCode)
                    .collect(Collectors.toList())).containsExactly("SOCK_R", "2-W", "SOCK_LS", "4-CR");
        } catch (IOException e) {
            fail("failed to load ClaimOrder.xml: " + e.getMessage());
        }
    }

    @Test
    public void itShouldCheckNumberOfScorableClaims() {
        // made all claims scorable, that's too many
        assertExceptionMessageContains("/ClaimOrder.TooManyScorable.xml", "Too many", "8");
    }

    @Test
    public void itShouldCheckExplicitDataOrder() {
        // SOCK_LS has an explicit dataOrder=6, which is invalid since there are only 4 scorable claims
        assertExceptionMessageContains("/ClaimOrder.BadDataOrder.xml", "Invalid", "6");
    }

    @Test
    public void itShouldCheckDuplicateDataOrder() {
        // SOCK_LS and 2-W both have dataOrder=3
        assertExceptionMessageContains("/ClaimOrder.DuplicateDataOrder.xml", "Duplicate", "3");
    }

    @Test
    public void itShouldLoadELPAC() {
        try (final InputStream is = this.getClass().getResourceAsStream("/ELPAC.xml")) {
            final Subject subject = service.parseSubject(is);
            assertThat(subject.getCode()).isEqualTo("ELPAC");
            assertThat(subject.getName()).isEqualTo("ELPAC");
            assertThat(subject.getAssessmentTypes()).hasSize(1);
            final SubjectAssessmentType subjectAssessmentType = subject.getAssessmentTypes().get(0);
            assertThat(subjectAssessmentType.isTargetReport()).isFalse();
            assertThat(subjectAssessmentType.isPrintedReport()).isFalse();
            assertThat(subjectAssessmentType.getAltScoring().getName()).isEqualTo("Composite");
            assertThat(subjectAssessmentType.getClaimScoring().getName()).isEqualTo("Domain");
            assertThat(subject.getAltScores()).hasSize(2);
            assertThat(subject.getClaims()).hasSize(4);
        } catch (IOException e) {
            fail("failed to load ELPAC.xml: " + e.getMessage());
        }
    }

    @Test
    public void itShouldLoadLatin() {
        try (final InputStream is = this.getClass().getResourceAsStream("/Latin.xml")) {
            final Subject subject = service.parseSubject(is);
            assertThat(subject.getCode()).isEqualTo("Latin");
            assertThat(subject.getName()).isEqualTo("Latin Proficiency");
            assertThat(subject.getAssessmentTypes()).hasSize(1);

            final SubjectAssessmentType subjectAssessmentType = subject.getAssessmentTypes().get(0);
            assertThat(subjectAssessmentType.isTargetReport()).isFalse();
            assertThat(subjectAssessmentType.isPrintedReport()).isTrue();

            assertThat(subjectAssessmentType.getClaimScoring().getName()).isEqualTo("Domain");
            assertThat(subject.getClaims()).hasSize(5);

            assertThat(subjectAssessmentType.isTraitReport()).isTrue();
            assertThat(subject.getTraits()).hasSize(5);
        } catch (IOException e) {
            fail("failed to load Latin.xml: " + e.getMessage());
        }
    }

    @Test
    public void itShouldDefaultPrintedReportTrue() {
        // reusing another test file
        try (final InputStream is = this.getClass().getResourceAsStream("/ClaimOrder.xml")) {
            final Subject subject = service.parseSubject(is);
            final SubjectAssessmentType asmtType = subject.getAssessmentTypes().get(0);
            assertThat(asmtType.isPrintedReport()).isTrue();
        } catch (IOException e) {
            fail("failed to load ClaimOrder.xml: " + e.getMessage());
        }
    }

    @Test
    public void itShouldLoadSubjectWithNoClaims() {
        try (final InputStream is = this.getClass().getResourceAsStream("/NoClaims.xml")) {
            final Subject subject = service.parseSubject(is);
            assertThat(subject.getClaims()).isNull();
            final SubjectAssessmentType asmtType = subject.getAssessmentTypes().get(0);
            assertThat(asmtType.getClaimScoring()).isNull();
        } catch (IOException e) {
            fail("failed to load NoClaims.xml: " + e.getMessage());
        }
    }

    @Test
    public void itShouldValidateColors() {
        assertExceptionMessageContains("/BadColors.xml", "color", "has a bad value");
    }

    private void assertExceptionMessageContains(final String resource, final String... msgSnippets) {
        try (final InputStream is = this.getClass().getResourceAsStream(resource)) {
            service.parseSubject(is);
            fail("it shouldn't have succeeded");
        } catch (final IOException e) {
            fail("failed to load " + resource + ": " + e.getMessage());
        } catch (final IllegalArgumentException e) {
            assertThat(e.getMessage()).contains(msgSnippets);
        }
    }

    private ReportGrade reportGrade(final String gradeCode) {
        return ReportGrade.builder()
                .code(gradeCode)
                .reportAssessmentTypes(ImmutableList.of(
                        ReportAssessmentType.builder()
                                .code("ica")
                                .overallAchievementMessage("Overall Grade Message " + gradeCode)
                                .reportClaims(ImmutableList.of(
                                        ReportClaim.builder()
                                                .code("SOCK_2")
                                                .performanceLevels(ImmutableList.of(
                                                        reportPerformanceLevel(1),
                                                        reportPerformanceLevel(2),
                                                        reportPerformanceLevel(3)
                                                ))
                                                .build()
                                ))
                                .reportPerformanceLevels(ImmutableList.of(
                                        reportPerformanceLevel(1),
                                        reportPerformanceLevel(2),
                                        reportPerformanceLevel(3),
                                        reportPerformanceLevel(4)))
                                .build()
                ))
                .build();
    }

    private ReportPerformanceLevel reportPerformanceLevel(final int performanceLevel) {
        return ReportPerformanceLevel.builder()
                .description("ReportPerformanceLevel Description " + performanceLevel)
                .level(performanceLevel)
                .build();
    }

    private Claim claim(final String code, final boolean scorable, final boolean organizational) {
        final Integer order = scorable ? claimIdx.getAndIncrement() : null;
        return Claim.builder()
                .code(code)
                .name("Claim " + code)
                .scorable(scorable)
                .organizational(organizational)
                .dataOrder(order)
                .displayOrder(order)
                .icon(scorable ? "icon_" + code : null)
                .description("Description " + code)
                .targets(organizational
                        ? ImmutableList.of(target(code, "OA|1"), target(code, "OA|2"))
                        : null)
                .build();
    }

    private Target target(final String claimCode, final String targetCode) {
        return Target.builder()
                .code(claimCode + "|" + targetCode)
                .name("Target name " + targetCode)
                .description("Target description " + targetCode)
                .build();
    }

    private SubjectAssessmentType assessmentType(final String typeCode, final String name, final Boolean targetReport) {
        return SubjectAssessmentType.builder()
                .code(typeCode)
                .name(name)
                .longName("Long " + name)
                .targetReport(targetReport)
                .overallScoring(OverallScoring.builder()
                    .performanceLevels(PerformanceLevels.builder().standardCutoff(2)
                        .performanceLevels(ImmutableList.of(performanceLevel(1), performanceLevel(2),  performanceLevel(3), performanceLevel(4)))
                        .build())
                    .build())
                .altScoring(typeCode.equals("iab") ? null : AltScoring.builder()
                    .name("Composite")
                    .performanceLevels(PerformanceLevels.builder()
                        .performanceLevels(ImmutableList.of(performanceLevel(1), performanceLevel(2)))
                        .build())
                    .build())
                .claimScoring(typeCode.equals("iab") ? null : ClaimScoring.builder()
                    .performanceLevels(PerformanceLevels.builder()
                        .performanceLevels(ImmutableList.of(performanceLevel(1), performanceLevel(2), performanceLevel(3)))
                        .build())
                    .build())
                .build();
    }

    private DepthOfKnowledge depthOfKnowledge(final int depth) {
        return DepthOfKnowledge.builder()
                .name("Depth " + depth)
                .level(depth)
                .reference(URI.create("http://depth.of.knowledge.com/" + depth + ".pdf"))
                .build();
    }

    private ItemDifficulty itemDifficulty(final int idx) {
        return ItemDifficulty.builder()
                .gradeCode("03")
                .moderateLowEnd(idx - 0.1)
                .difficultLowEnd(idx + 0.1)
                .build();
    }

    static PerformanceLevel performanceLevel(final int level) {
        return PerformanceLevel.builder()
                .level(level)
                .name("Level " + level)
                .shortName("Short " + level)
                .suffix("Suffix")
                .color("blue")
                .build();
    }

    private Standard standard(final String code) {
        return Standard.builder()
                .code(code)
                .description("Description " + code)
                .build();
    }
}
