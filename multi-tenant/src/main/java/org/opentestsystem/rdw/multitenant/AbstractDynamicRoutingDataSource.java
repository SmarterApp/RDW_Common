package org.opentestsystem.rdw.multitenant;

import org.springframework.jdbc.datasource.AbstractDataSource;
import org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource;

import javax.sql.DataSource;
import java.sql.Connection;
import java.sql.SQLException;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Abstract {@link javax.sql.DataSource} implementation that routes {@link #getConnection()}
 * calls to one of various lazily dynamically created DataSources based on a lookup key.
 * The latter is usually (but not necessarily) determined through some thread-bound transaction context.
 * <p>
 * Based on {@link AbstractRoutingDataSource}
 */
public abstract class AbstractDynamicRoutingDataSource extends AbstractDataSource {

    private final ConcurrentHashMap<Object, DataSource> resolvedDataSources = new ConcurrentHashMap<>();

    @Override
    public Connection getConnection() throws SQLException {
        return determineTargetDataSource().getConnection();
    }

    @Override
    public Connection getConnection(String username, String password) throws SQLException {
        return determineTargetDataSource().getConnection(username, password);
    }

    @Override
    @SuppressWarnings("unchecked")
    public <T> T unwrap(Class<T> iface) throws SQLException {
        if (iface.isInstance(this)) {
            return (T) this;
        }
        return determineTargetDataSource().unwrap(iface);
    }

    @Override
    public boolean isWrapperFor(Class<?> iface) throws SQLException {
        return (iface.isInstance(this) || determineTargetDataSource().isWrapperFor(iface));
    }

    /**
     * Retrieve the current target DataSource. Determines the
     * {@link #determineCurrentLookupKey() current lookup key}, performs
     * a lookup in the targetDataSources map
     */
    protected DataSource determineTargetDataSource() {
        Object lookupKey = determineCurrentLookupKey();
        if (!resolvedDataSources.containsKey(lookupKey)) {
            //avoid problem of 2 simultaneous new calls to new tenant
            resolvedDataSources.putIfAbsent(lookupKey, dataSourceFactory(lookupKey));
        }
        return resolvedDataSources.get(lookupKey);
    }

    /**
     * Determine the current lookup key. This will typically be
     * implemented to check a thread-bound transaction context.
     * <p>Allows for arbitrary keys.
     */
    protected abstract Object determineCurrentLookupKey();


    /**
     * Create a new datasource based off of lookupKey.  This is called
     * by @link {#determineTargetDataSource} if no existing datasource for
     * this key exists.
     */
    protected abstract DataSource dataSourceFactory(Object lookupKey);

}

