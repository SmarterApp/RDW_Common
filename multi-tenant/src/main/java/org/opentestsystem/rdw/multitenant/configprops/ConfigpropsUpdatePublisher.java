package org.opentestsystem.rdw.multitenant.configprops;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.common.collect.ImmutableMap;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.actuate.endpoint.ConfigurationPropertiesReportEndpoint;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.cloud.context.config.annotation.RefreshScope;
import org.springframework.cloud.context.environment.EnvironmentChangeEvent;
import org.springframework.cloud.context.refresh.ContextRefresher;
import org.springframework.context.event.EventListener;
import org.springframework.messaging.Message;
import org.springframework.messaging.MessageHeaders;
import org.springframework.messaging.support.MessageBuilder;

import java.util.Map;

/**
 * Publishes {@link ConfigpropsUpdateMessage} contains the equivalent of the "/configprops" actuator endpoint.
 * <p>
 * This class listens for {@link EnvironmentChangeEvent}.
 * It is fired after {@link ContextRefresher#refresh()} completes,
 * and beans that use {@link RefreshScope} will have been updated by then.
 * The message is extracted from {@link ConfigurationPropertiesReportEndpoint}
 * <p>
 * This class also listens for {@link ApplicationReadyEvent} in order bootstrap the
 * configuration process on application start.
 *
 * <p>
 * Spring cloud stream bindings configuration for publication:
 *
 * <pre>
 * spring:
 *   cloud:
 *     stream:
 *       bindings:
 *         configprops-update-output:
 *           destination: configprops-update-exchange
 * </pre>
 */
public class ConfigpropsUpdatePublisher {

    private static final Logger logger = LoggerFactory.getLogger(ConfigpropsUpdatePublisher.class);

    private final String serviceName;
    private final ConfigpropsProcessor configpropsProcessor;
    private final ConfigurationPropertiesReportEndpoint configurationPropertiesReportEndpoint;
    private final ObjectMapper objectMapper;

    public ConfigpropsUpdatePublisher(String serviceName,
                                      ConfigpropsProcessor configpropsProcessor,
                                      ConfigurationPropertiesReportEndpoint configurationPropertiesReportEndpoint,
                                      ObjectMapper objectMapper) {
        this.serviceName = serviceName;
        this.configpropsProcessor = configpropsProcessor;
        this.configurationPropertiesReportEndpoint = configurationPropertiesReportEndpoint;
        this.objectMapper = objectMapper;
    }

    /**
     * Listen for {@link EnvironmentChangeEvent} and publish configprops
     *
     * @param environmentChangeEvent event payload
     */
    @EventListener
    public void environmentChangeEventPublish(final EnvironmentChangeEvent environmentChangeEvent) {
        final String json = retrieveConfigpropsAsJson();
        logger.debug("EnvironmentChangeEvent - eventKeys {} configprops {} ", environmentChangeEvent.getKeys(), json);
        publishConfigprops(json);
    }


// TODO: not late enough in lifecycle to work, queues haven't been created yet
//
//    /**
//     * Listen for {@link ApplicationReadyEvent} and publish configprops
//     *
//     * @param applicationReadyEvent event payload
//     */
//    @EventListener
//    public void applicationReadyEventPublish(final ApplicationReadyEvent applicationReadyEvent) {
//        final String json = retrieveConfigpropsAsJson();
//        logger.debug("ApplicationReadyEvent - configprops {} ", json);
//        publishConfigprops(json);
//    }

    private String retrieveConfigpropsAsJson() {
        Map<String, Object> configprops = configurationPropertiesReportEndpoint.invoke();
        try {
            return objectMapper.writeValueAsString(configprops);
        } catch (JsonProcessingException e) {
            throw new IllegalStateException("Unable to parse configprops to JSON", e);
        }
    }

    private void publishConfigprops(final String json) {
        final ConfigpropsUpdateMessage payload = ConfigpropsUpdateMessage.builder()
                .configprops(json)
                .serviceName(serviceName)
                .build();
        Map<String, Object> headers = ImmutableMap.of("serviceName", serviceName);
        final Message<ConfigpropsUpdateMessage> message =
                MessageBuilder.createMessage(payload, new MessageHeaders(headers));
        configpropsProcessor.configpropsUpdateOutput().send(message);
    }

}

