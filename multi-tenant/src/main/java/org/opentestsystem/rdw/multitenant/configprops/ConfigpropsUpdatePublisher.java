package org.opentestsystem.rdw.multitenant.configprops;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.common.collect.ImmutableMap;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.actuate.endpoint.ConfigurationPropertiesReportEndpoint;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.cloud.context.config.annotation.RefreshScope;
import org.springframework.cloud.context.environment.EnvironmentChangeEvent;
import org.springframework.cloud.context.refresh.ContextRefresher;
import org.springframework.context.event.EventListener;
import org.springframework.messaging.Message;
import org.springframework.messaging.MessageHeaders;
import org.springframework.messaging.support.MessageBuilder;
import org.springframework.scheduling.annotation.Scheduled;

import java.util.Map;

/**
 * Publishes {@link ConfigpropsUpdateMessage} contains the equivalent of the "/configprops" actuator endpoint.
 * <p>
 * This class listens for {@link EnvironmentChangeEvent}.
 * It is fired after {@link ContextRefresher#refresh()} completes,
 * and beans that use {@link RefreshScope} will have been updated by then.
 * The message is extracted from {@link ConfigurationPropertiesReportEndpoint}
 * <p>
 * This class publishes on a schedule in order bootstrap the
 * configuration process on application start.
 *
 * <p>
 * Spring cloud stream bindings configuration for publication:
 *
 * <pre>
 * spring:
 *   cloud:
 *     stream:
 *       bindings:
 *         ConfigpropsUpdateOutput:
 *           destination: ConfigpropsUpdateExchange
 * </pre>
 */
public class ConfigpropsUpdatePublisher {
    private static final Logger logger = LoggerFactory.getLogger(ConfigpropsUpdatePublisher.class);

    private final String serviceName;
    private final ConfigpropsProcessor configpropsProcessor;
    private final ConfigurationPropertiesReportEndpoint configurationPropertiesReportEndpoint;
    private final ObjectMapper objectMapper;

    public ConfigpropsUpdatePublisher(String serviceName,
                                      ConfigpropsProcessor configpropsProcessor,
                                      ConfigurationPropertiesReportEndpoint configurationPropertiesReportEndpoint,
                                      ObjectMapper objectMapper) {
        this.serviceName = serviceName;
        this.configpropsProcessor = configpropsProcessor;
        this.configurationPropertiesReportEndpoint = configurationPropertiesReportEndpoint;
        this.objectMapper = objectMapper;
    }

    /**
     * Listen for {@link EnvironmentChangeEvent} and publish configprops
     *
     * @param environmentChangeEvent event payload
     */
    @EventListener
    public void environmentChangeEventPublish(final EnvironmentChangeEvent environmentChangeEvent) {
        logger.debug("EnvironmentChangeEvent - {}", environmentChangeEvent);
        try {
            publishConfigprops();
        } catch (Exception e) {
            //no end user log only
            logger.warn("Unable to publish configprops", e);
        }
    }

    /**
     * Publish configprops on a schedule.  Mostly a workaround for {@link ApplicationReadyEvent} not occurring
     * late enough for cloud stream to be fully operational.  Provides a bootstrap for the central configuration
     * that is not based configuration change events.  It will continue to publish periodically after the initial
     * delay.
     */
    @Scheduled(fixedDelayString = "${app.configpropsPublish.fixedDelay:180000}",
            initialDelayString = "${app.configpropsPublish.initialDelay:30000}")
    public void scheduledPublish() {
        logger.debug("Executing scheduled publish");
        try {
            publishConfigprops();
        } catch (Exception e) {
            //no end user log only
            logger.warn("Unable to publish configprops", e);
        }

    }

    private void publishConfigprops() {
        final String json = retrieveConfigpropsAsJson();
        logger.debug("configprops {}", json);
        final ConfigpropsUpdateMessage payload = ConfigpropsUpdateMessage.builder()
                .configprops(json)
                .serviceName(serviceName)
                .build();
        Map<String, Object> headers = ImmutableMap.of("serviceName", serviceName);
        final Message<ConfigpropsUpdateMessage> message =
                MessageBuilder.createMessage(payload, new MessageHeaders(headers));
        configpropsProcessor.configpropsUpdateOutput().send(message);
    }

    private String retrieveConfigpropsAsJson() {
        Map<String, Object> configprops = configurationPropertiesReportEndpoint.invoke();
        try {
            return objectMapper.writeValueAsString(configprops);
        } catch (JsonProcessingException e) {
            throw new IllegalStateException("Unable to parse configprops to JSON", e);
        }
    }
}

