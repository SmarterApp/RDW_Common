package org.opentestsystem.rdw.script;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import org.opentestsystem.rdw.common.model.ImportException;
import org.opentestsystem.rdw.script.security.SandboxSecurityManager;

/**
 * A Pipeline is a series of precompiled scripts that run against input in order to
 * transform, filter, and validate it.
 */
public class Pipeline {
    private static final Logger logger = LoggerFactory.getLogger(Pipeline.class);

    private static final int SANDBOX_RETRIES = 2;
    private static final int SANDBOX_THREADS = 2;
    private static final ExecutorService THREAD_POOL = Executors.newFixedThreadPool(SANDBOX_THREADS);

    private final PipelineDefinition pipelineDefinition;
    private final List<ScriptDefinition> scriptDefinitions;
    private final SandboxSecurityManager sandboxSecurityManager;

    public Pipeline(final PipelineDefinition pipelineDefinition,
                    final List<ScriptDefinition> scriptDefinitions,
                    final SandboxSecurityManager sandboxSecurityManager) {
        this.pipelineDefinition = pipelineDefinition;
        this.scriptDefinitions = scriptDefinitions;

        if (hasUserNodes()) {
            this.sandboxSecurityManager = sandboxSecurityManager;
            System.setSecurityManager(sandboxSecurityManager);
        } else {
            this.sandboxSecurityManager = null;
        }
    }

    public PipelineDefinition getPipelineDefinition() {
        return pipelineDefinition;
    }

    public PipelineResults run(final Object input)  {

        Object lastValidTransformation = input;

        for (final ScriptDefinition sd : scriptDefinitions) {
            try {
                final PipelineScript script = getInstance(sd, lastValidTransformation);

                final Object results = runScript(script, sd.isSystemScript());

                if (results == null) {
                    // (A script always returns the value of its last expression, so this is unlikely to happen.)
                    throw new RuntimeException("Script " + sd.toString() + " returned null results.");
                }

                lastValidTransformation = results;
            } catch (ScriptRuntimeException sre) {
                throw sre;
            } catch (Exception e) {
                logger.warn("Pipeline runtime error", e);
                throw new RuntimeException("Runtime error in script: " + sd + ": " + e.getMessage(), e);
            }
        }

        final boolean modified = checkForModifications(input, lastValidTransformation);
        return new PipelineResults(lastValidTransformation, modified);
    }

    private boolean checkForModifications(final Object input, final Object lastValidTransformation) {
        if (input instanceof byte[] && lastValidTransformation instanceof byte[]) {
            return !Arrays.equals((byte[])input, (byte[])lastValidTransformation);
        }

        return input != lastValidTransformation;
    }

    private Object runScript(final PipelineScript script, final boolean isSystemScript) {
        if (isSystemScript || sandboxSecurityManager == null) {
            return script.execute();
        }

        for (int i = 0; i < SANDBOX_RETRIES; i++) {
            final Callable<Object> callable = () -> {
                sandboxSecurityManager.enable();
                return script.execute();
            };

            final Future<Object> future = THREAD_POOL.submit(callable);

            try {
                return future.get();
            } catch (ExecutionException e) {

                // Unwrap the cause and rethrow.
                final ScriptRuntimeException cause = extractCause(e);
                if (cause == null) {
                    throw new RuntimeException("Error in pipeline:", e);
                } else {
                    throw cause;
                }
            } catch (InterruptedException e) {
                logger.warn("Processing interrupted: " + e.getMessage());
            }
        }

        // Too many InterruptedExceptions.
        throw new RuntimeException("Too many interrupted exceptions. Cannot process script.");
    }

    private ScriptRuntimeException extractCause(final Throwable t) {
        Throwable cause = t;

        while(cause != null && cause.getCause() != cause) {
            cause = cause.getCause();
            if (cause instanceof ScriptRuntimeException) {
                return (ScriptRuntimeException)cause;
            }
        }

        return null;
    }

    private boolean hasUserNodes() {
        return scriptDefinitions.stream()
                .anyMatch(ScriptDefinition::isUserScript);
    }

    /**
     * Get an instance of the script to be run against the given input
     *
     * @param input an open Reader with the input file for the script to work on
     * @return an instance of a PipelineScript
     * @throws Exception if there is an problem constructing the script
     */
    public PipelineScript getInstance(final ScriptDefinition scriptDefinition, final Object input) throws Exception {
        return getInstance(scriptDefinition, input, null);
    }

    /**
     * Get an instance of the script to be run against the given input and properties.
     *
     * @param input                   an open Reader with the input file for the script to work on
     * @param additionalConfiguration a Map of string properties that will be added to the configuration and
     *                                made available to the scripts
     * @return an instance of a PipelineScript
     * @throws Exception if there is an problem constructing the script
     */
    public PipelineScript getInstance(
            final ScriptDefinition scriptDefinition,
            final Object input,
            final Map<String, Object> additionalConfiguration) throws Exception {
        final PipelineScript script = scriptDefinition.getCompiledScript().getConstructor().newInstance()
                .bindProperties(scriptDefinition.getConfiguration())
                .bindProperties(additionalConfiguration)
                .bindInput(input);

        if (scriptDefinition.isSystemScript() && scriptDefinition.getPropertyResolver() != null) {
            script.setProperty("propertyResolver", scriptDefinition.getPropertyResolver());
        }

        return script;
    }
}
