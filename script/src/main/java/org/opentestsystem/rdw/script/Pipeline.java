package org.opentestsystem.rdw.script;

import org.opentestsystem.rdw.script.security.SandboxSecurityManager;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.validation.constraints.NotNull;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

import static com.google.common.collect.ImmutableList.copyOf;

/**
 * A Pipeline is a series of precompiled scripts that run against input in order to
 * transform, filter, and validate it.
 */
public class Pipeline {
    private static final Logger logger = LoggerFactory.getLogger(Pipeline.class);
    private static final int SANDBOX_RETRIES = 2;
    private static final int SANDBOX_THREADS = 2;
    private static final ExecutorService THREAD_POOL = Executors.newFixedThreadPool(SANDBOX_THREADS);

    private final PipelineDefinition source;
    private final List<PipelineScript> scripts;
    private final SandboxSecurityManager sandboxSecurityManager;

    public Pipeline(
            @NotNull final PipelineDefinition source,
            @NotNull final List<PipelineScript> scripts,
            final SandboxSecurityManager sandboxSecurityManager) {

        this.source = source;
        this.scripts = copyOf(scripts);

        // TODO pull this up a level to the pipeline factory?
        final boolean requiresSecurity = scripts.stream()
                .anyMatch(script -> script.getSource().getType() == PipelineScriptType.User);

        if (requiresSecurity) {
            this.sandboxSecurityManager = sandboxSecurityManager;
            System.setSecurityManager(sandboxSecurityManager);
        } else {
            this.sandboxSecurityManager = null;
        }
    }

    public PipelineDefinition getSource() {
        return source;
    }

    public List<PipelineScript> getScripts() {
        return scripts;
    }

    public PipelineResults run(final Object input) {

        Object lastValidTransformation = input;

        for (final PipelineScript script : scripts) {
            try {
                script.bindInput(lastValidTransformation);

                final Object results = runScript(script);

                if (results == null) {
                    // (A script always returns the value of its last expression, so this is unlikely to happen.)
                    throw new RuntimeException(String.format(
                            "Script %s returned null results.",
                            script
                    ));
                }

                lastValidTransformation = results;
            } catch (final ScriptRuntimeException exception) {
                throw exception;
            } catch (final Exception exception) {
                logger.warn("Pipeline runtime error", exception);
                throw new RuntimeException(
                        String.format(
                                "Runtime error in script: %s: %s",
                                script,
                                exception.getMessage()
                        ),
                        exception
                );
            }
        }

        return new PipelineResults(
                lastValidTransformation,
                !equals(input, lastValidTransformation)
        );
    }

    private boolean equals(final Object a, final Object b) {
        if (a instanceof byte[] && b instanceof byte[]) {
            return Arrays.equals((byte[]) a, (byte[]) b);
        }
        return a == b;
    }

    private Object runScript(final PipelineScript script) {

        final boolean isSystemScript = script.getSource().getType() != PipelineScriptType.User;
        if (isSystemScript || sandboxSecurityManager == null) {
            return script.execute();
        }

        for (int i = 0; i < SANDBOX_RETRIES; i++) {
            final Callable<Object> callable = () -> {
                sandboxSecurityManager.enable();
                return script.execute();
            };

            final Future<Object> future = THREAD_POOL.submit(callable);

            try {
                return future.get();
            } catch (final ExecutionException exception) {

                // Unwrap the cause and rethrow.
                final ScriptRuntimeException cause = extractCause(exception);
                if (cause == null) {
                    throw new RuntimeException("Error in pipeline:", exception);
                } else {
                    throw cause;
                }
            } catch (final InterruptedException exception) {
                logger.warn("Processing interrupted: " + exception.getMessage());
            }
        }

        // Too many InterruptedExceptions.
        throw new RuntimeException("Too many interrupted exceptions. Cannot process script.");
    }

    private ScriptRuntimeException extractCause(final Throwable t) {
        Throwable cause = t;

        while (cause != null && cause.getCause() != cause) {
            cause = cause.getCause();
            if (cause instanceof ScriptRuntimeException) {
                return (ScriptRuntimeException) cause;
            }
        }

        return null;
    }

}
