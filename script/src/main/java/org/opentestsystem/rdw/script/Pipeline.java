package org.opentestsystem.rdw.script;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

import org.opentestsystem.rdw.script.security.SandboxSecurityManager;

/**
 * A Pipeline is a series of precompiled scripts that run against input in order to
 * transform, filter, and validate it.
 */
public class Pipeline {
    private static final Logger logger = LoggerFactory.getLogger(Pipeline.class);

    private static final int SANDBOX_RETRIES = 2;
    private static final int SANDBOX_THREADS = 2;
    private static final ExecutorService THREAD_POOL = Executors.newFixedThreadPool(SANDBOX_THREADS);

    private final PipelineDefinition pipelineDefinition;
    private final List<ScriptDefinition> scriptDefinitions;
    private final SandboxSecurityManager sandboxSecurityManager;

    public Pipeline(final PipelineDefinition pipelineDefinition,
                    final List<ScriptDefinition> scriptDefinitions,
                    final SandboxSecurityManager sandboxSecurityManager) {
        this.pipelineDefinition = pipelineDefinition;
        this.scriptDefinitions = scriptDefinitions;

        if (hasUserNodes()) {
            this.sandboxSecurityManager = sandboxSecurityManager;
            System.setSecurityManager(sandboxSecurityManager);
        } else {
            this.sandboxSecurityManager = null;
        }
    }

    public PipelineDefinition getPipelineDefinition() {
        return pipelineDefinition;
    }

    public PipelineResults run(final Object input)  {

        Object lastValidTransformation = input;

        for (final ScriptDefinition scriptDefinition : scriptDefinitions) {
            try {
                final PipelineScript script = scriptDefinition.getInstance(lastValidTransformation);

                final Object results = runScript(script, scriptDefinition.isUserCreated());

                if (results == null) {
                    // (A script always returns the value of its last expression, so this is unlikely to happen.)
                    throw new RuntimeException("Script " + scriptDefinition.toString() + " returned null results.");
                }

                lastValidTransformation = results;
            } catch (ScriptRuntimeException sre) {
                throw sre;
            } catch (Exception e) {
                logger.warn("Pipeline runtime error", e);
                throw new RuntimeException("Runtime error in script: " + scriptDefinition + ": " + e.getMessage(), e);
            }
        }

        return new PipelineResults(lastValidTransformation);
    }

    private Object runScript(final PipelineScript script, final boolean userCreated) {
        if (!userCreated || sandboxSecurityManager == null) {
            return script.execute();
        }

        for (int i = 0; i < SANDBOX_RETRIES; i++) {
            final Callable<Object> callable = () -> {
                sandboxSecurityManager.enable();
                return script.execute();
            };

            final Future<Object> future = THREAD_POOL.submit(callable);

            try {
                return future.get();
            } catch (ExecutionException e) {

                // Unwrap the cause and rethrow.
                final ScriptRuntimeException cause = extractCause(e);
                if (cause == null) {
                    throw new RuntimeException("Error in pipeline:", e);
                } else {
                    throw cause;
                }
            } catch (InterruptedException e) {
                logger.warn("Processing interrupted: " + e.getMessage());
            }
        }

        // Too many InterruptedExceptions.
        throw new RuntimeException("Too many interrupted exceptions. Cannot process script.");
    }

    private ScriptRuntimeException extractCause(final Throwable t) {
        Throwable cause = t;

        while(cause != null && cause.getCause() != cause) {
            cause = cause.getCause();
            if (cause instanceof ScriptRuntimeException) {
                return (ScriptRuntimeException)cause;
            }
        }

        return null;
    }

    private boolean hasUserNodes() {
        return scriptDefinitions.stream()
                .anyMatch(ScriptDefinition::isUserCreated);
    }
}
