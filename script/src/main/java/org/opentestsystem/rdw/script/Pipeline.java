package org.opentestsystem.rdw.script;

import org.opentestsystem.rdw.script.publishing.PublishedPipeline;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import org.opentestsystem.rdw.script.publishing.ScriptType;
import org.opentestsystem.rdw.script.security.SandboxSecurityManager;

import static com.google.common.collect.ImmutableList.copyOf;
import static com.google.common.collect.ImmutableList.of;

/**
 * A Pipeline is a series of precompiled scripts that run against input in order to
 * transform, filter, and validate it.
 */
public class Pipeline {
    private static final Logger logger = LoggerFactory.getLogger(Pipeline.class);

    private static final int SANDBOX_RETRIES = 2;
    private static final int SANDBOX_THREADS = 2;
    private static final ExecutorService THREAD_POOL = Executors.newFixedThreadPool(SANDBOX_THREADS);

    private final PublishedPipeline source;
    private final List<PipelineScript> scripts;
    private final SandboxSecurityManager sandboxSecurityManager;

    public Pipeline(final PublishedPipeline source,
                    final List<PipelineScript> scripts,
                    final SandboxSecurityManager sandboxSecurityManager) {
        this.source = source;
        this.scripts = scripts != null ? copyOf(scripts) : of();

        if (hasUserNodes()) {
            this.sandboxSecurityManager = sandboxSecurityManager;
            System.setSecurityManager(sandboxSecurityManager);
        } else {
            this.sandboxSecurityManager = null;
        }
    }

    public PublishedPipeline getSource() {
        return source;
    }

    public List<PipelineScript> getScripts() {
        return scripts;
    }

    public PipelineResults run(final Object input)  {

        Object lastValidTransformation = input;

        for (final PipelineScript script : scripts) {
            try {
//                final PipelineScript script = getInstance(scriptDefinition, lastValidTransformation);

                script.bindInput(lastValidTransformation);

                final Object results = runScript(script, script.getSource().getType() != ScriptType.User);

                if (results == null) {
                    // (A script always returns the value of its last expression, so this is unlikely to happen.)
                    throw new RuntimeException("Script " + script.toString() + " returned null results.");
                }

                lastValidTransformation = results;
            } catch (ScriptRuntimeException sre) {
                throw sre;
            } catch (Exception e) {
                logger.warn("Pipeline runtime error", e);
                throw new RuntimeException("Runtime error in script: " + script + ": " + e.getMessage(), e);
            }
        }

        final boolean modified = checkForModifications(input, lastValidTransformation);
        return new PipelineResults(lastValidTransformation, modified);
    }

    private boolean checkForModifications(final Object input, final Object lastValidTransformation) {
        if (input instanceof byte[] && lastValidTransformation instanceof byte[]) {
            return !Arrays.equals((byte[])input, (byte[])lastValidTransformation);
        }

        return input != lastValidTransformation;
    }

    private Object runScript(final PipelineScript script, final boolean isSystemScript) {
        if (isSystemScript || sandboxSecurityManager == null) {
            return script.execute();
        }

        for (int i = 0; i < SANDBOX_RETRIES; i++) {
            final Callable<Object> callable = () -> {
                sandboxSecurityManager.enable();
                return script.execute();
            };

            final Future<Object> future = THREAD_POOL.submit(callable);

            try {
                return future.get();
            } catch (ExecutionException e) {

                // Unwrap the cause and rethrow.
                final ScriptRuntimeException cause = extractCause(e);
                if (cause == null) {
                    throw new RuntimeException("Error in pipeline:", e);
                } else {
                    throw cause;
                }
            } catch (InterruptedException e) {
                logger.warn("Processing interrupted: " + e.getMessage());
            }
        }

        // Too many InterruptedExceptions.
        throw new RuntimeException("Too many interrupted exceptions. Cannot process script.");
    }

    private ScriptRuntimeException extractCause(final Throwable t) {
        Throwable cause = t;

        while(cause != null && cause.getCause() != cause) {
            cause = cause.getCause();
            if (cause instanceof ScriptRuntimeException) {
                return (ScriptRuntimeException)cause;
            }
        }

        return null;
    }

    private boolean hasUserNodes() {
        return scripts.stream()
                .anyMatch(script -> script.getSource().getType() == ScriptType.User);
    }

}
