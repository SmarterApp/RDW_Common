package org.opentestsystem.rdw.script;

import com.google.common.base.MoreObjects;
import com.google.common.collect.ImmutableMap;
import org.opentestsystem.rdw.script.publishing.PublishedScript;
import org.opentestsystem.rdw.script.publishing.ScriptType;

import java.util.Map;

import static com.google.common.collect.ImmutableMap.of;

/**
 * Script definition for pipeline nodes scripts.
 *
 * TODO stop inheriting versioned resource
 */
public class ScriptDefinition extends VersionedResource {

    private PublishedScript source;
    private Class<? extends PipelineScript> compiledScript;
    private Map<String, Object> configuration;
    private PropertyResolver propertyResolver;

    public PublishedScript getSource() {
        return source;
    }

    public boolean isUserScript() {
        return source.getType() == ScriptType.User;
    }

    public boolean isSystemScript() {
        return source.getType() != ScriptType.User;
    }

    public Class<? extends PipelineScript> getCompiledScript() {
        return compiledScript;
    }

    public Map<String, Object> getConfiguration() {
        return configuration;
    }

    public PropertyResolver getPropertyResolver() {
        return propertyResolver;
    }

    /**
     * TODO move to service
     *
     * Get an instance of the script to be run against the given input
     *
     * @param input an open Reader with the input file for the script to work on
     * @return an instance of a PipelineScript
     * @throws Exception if there is an problem constructing the script
     */
    public PipelineScript getInstance(Object input) throws Exception {
        return getInstance(input, null);
    }

    /**
     * TODO move to service
     *
     * Get an instance of the script to be run against the given input and properties.
     *
     * @param input                   an open Reader with the input file for the script to work on
     * @param additionalConfiguration a Map of string properties that will be added to the configuration and
     *                                made available to the scripts
     * @return an instance of a PipelineScript
     * @throws Exception if there is an problem constructing the script
     */
    public PipelineScript getInstance(Object input, Map<String, Object> additionalConfiguration) throws Exception {
        final PipelineScript script = compiledScript.getConstructor().newInstance()
                .bindProperties(configuration)
                .bindProperties(additionalConfiguration)
                .bindInput(input);

        if (isSystemScript() && this.propertyResolver != null) {
            script.setProperty("propertyResolver", propertyResolver);
        }

        return script;
    }

    public String toString() {
        return MoreObjects.toStringHelper(this)
                .add("source", getSource())
                .add("configuration", getConfiguration())
                .toString();
    }

    public static Builder builder() {
        return new Builder();
    }

    public static class Builder extends VersionedResource.Builder<ScriptDefinition, Builder> {
        private PublishedScript source;
        private Class<? extends PipelineScript> compiledScript;
        private Map<String, Object> configuration;
        private PropertyResolver propertyResolver;

        public Builder source(final PublishedScript source) {
            this.source = source;
            return this;
        }

        public Builder compiledScript(final Class<? extends PipelineScript> compiledScript) {
            this.compiledScript = compiledScript;
            return this;
        }

        public Builder configuration(final Map<String, Object> configuration) {
            this.configuration = configuration != null ? ImmutableMap.copyOf(configuration) : null;
            return this;
        }

        public Builder propertyResolver(final PropertyResolver propertyResolver) {
            this.propertyResolver = propertyResolver;
            return this;
        }

        protected ScriptDefinition build(final ScriptDefinition instance) {
            super.build(instance);
            instance.source = source;
            instance.compiledScript = compiledScript;
            instance.configuration = configuration != null ? configuration : of();
            instance.propertyResolver = propertyResolver;
            return instance;
        }

        public ScriptDefinition build() {
            return build(new ScriptDefinition());
        }

    }
}
