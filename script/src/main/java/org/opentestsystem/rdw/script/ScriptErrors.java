package org.opentestsystem.rdw.script;

import groovy.lang.GroovyRuntimeException;
import org.codehaus.groovy.control.CompilationFailedException;
import org.codehaus.groovy.control.ErrorCollector;
import org.codehaus.groovy.control.MultipleCompilationErrorsException;
import org.codehaus.groovy.control.messages.Message;
import org.codehaus.groovy.control.messages.SyntaxErrorMessage;
import org.codehaus.groovy.syntax.SyntaxException;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.ArrayList;
import java.util.List;

import static java.util.Collections.singletonList;

/**
 * Converters for various script exceptions into ScriptError objects for consumption by front-end services.
 */
public class ScriptErrors {

    /**
     * Convert a GroovyRuntimeException to ScriptError using the row and column information from the AST Node
     * if available.
     *
     * @param exception the GroovyRuntimeException
     * @return a ScriptError populated with the exception's message and row and column information if available.
     */
    public static ScriptError toScriptError(final GroovyRuntimeException exception) {
        return exception.getNode() == null
                ? new ScriptError(
                        exception.getMessage()
                )
                : new ScriptError(
                        exception.getMessage(),
                        exception.getNode().getLineNumber(),
                        exception.getNode().getColumnNumber()
                );
    }

    /**
     * Convert a ScriptRuntimeException, which is thrown for any runtime errors in a PipelineScript.
     *
     * @param exception the ScriptRuntimeException
     * @return a ScriptError populated with the error message and script line number. Column will always be null.
     */
    public static ScriptError toScriptError(final ScriptRuntimeException exception) {
        return new ScriptError(
                exception.getOriginalMessage(),
                exception.getLineNumber()
        );
    }

    /**
     * Convert a CompilationFailedException, which wraps one or more compilation errors.
     *
     * @param exception the CompilationFailedException
     * @return List of ScriptErrors, populated with the compile error messages, start lines, and start columns
     */
    public static List<ScriptError> toScriptErrors(final CompilationFailedException exception) {
        if (exception instanceof MultipleCompilationErrorsException) {
            return toScriptErrors((MultipleCompilationErrorsException) exception);
        }
        return singletonList(toScriptError(exception));
    }

    private static List<ScriptError> toScriptErrors(final MultipleCompilationErrorsException exception) {
        final ErrorCollector errorCollector = exception.getErrorCollector();
        if (errorCollector == null
        || errorCollector.getErrors() == null
        || errorCollector.getErrors().isEmpty()) {
            return singletonList(toScriptError(exception));
        }

        final List<ScriptError> errors = new ArrayList<>();

        for (final Object error : errorCollector.getErrors()) {
            if (error instanceof SyntaxErrorMessage) {
                errors.add(toScriptError(
                        ((SyntaxErrorMessage) error).getCause()
                ));
            } else if (error instanceof Message) {
                final Message message = (Message) error;
                final StringWriter stringWriter = new StringWriter();
                message.write(new PrintWriter(stringWriter));
                errors.add(new ScriptError(stringWriter.toString()));
            }
        }

        return errors;
    }

    private static ScriptError toScriptError(final SyntaxException exception) {
        return new ScriptError(
                exception.getOriginalMessage(),
                exception.getStartLine(),
                exception.getStartColumn()
        );
    }
}
