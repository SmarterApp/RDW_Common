package org.opentestsystem.rdw.script.impl;

import org.codehaus.groovy.control.CompilationFailedException;
import org.opentestsystem.rdw.script.ConfigurationCompiler;
import org.opentestsystem.rdw.script.Pipeline;
import org.opentestsystem.rdw.script.PipelineBuildException;
import org.opentestsystem.rdw.script.PipelineDefinition;
import org.opentestsystem.rdw.script.PipelineFactory;
import org.opentestsystem.rdw.script.PipelineScript;
import org.opentestsystem.rdw.script.PropertyResolver;
import org.opentestsystem.rdw.script.ScriptCompiler;
import org.opentestsystem.rdw.script.ScriptDefinition;
import org.opentestsystem.rdw.script.ScriptInfo;
import org.opentestsystem.rdw.script.ScriptSource;
import org.opentestsystem.rdw.script.publishing.PublishedPipeline;
import org.opentestsystem.rdw.script.publishing.PublishedPipelineRepository;
import org.opentestsystem.rdw.script.publishing.PublishedScript;
import org.opentestsystem.rdw.script.publishing.ScriptType;
import org.opentestsystem.rdw.script.security.SandboxSecurityManager;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;

import static com.google.common.collect.Lists.newArrayList;
import static java.util.stream.Collectors.toList;
import static org.opentestsystem.rdw.script.ScriptCompilers.toScriptCompiler;
import static org.opentestsystem.rdw.script.publishing.ScriptType.Base;
import static org.opentestsystem.rdw.script.publishing.ScriptType.Post;
import static org.opentestsystem.rdw.script.publishing.ScriptType.Pre;
import static org.opentestsystem.rdw.script.publishing.ScriptType.User;

/**
 * Factory class for creating a Pipeline by loading the pipeline definition and then using it to
 * load the script definitions for each node.
 */
public class DefaultPipelineFactory implements PipelineFactory {

    private static PipelineDefinition toPipelineDefinition(final PublishedPipeline publishedPipeline) {
        return PipelineDefinition.builder()
                .source(publishedPipeline)
                .scripts(
                        publishedPipeline.getScripts().stream()
                                .map(publishedScript -> ScriptDefinition.builder()
                                        .source(publishedScript)
                                        .build()
                                )
                                .collect(toList())
                )
                .build();
    }

    private final PublishedPipelineRepository repository;
    // Compiler of configuration properties, which may involve loading database connections and
    // other manipulations
    private final ConfigurationCompiler configCompiler;
    private final PropertyResolver propertyResolver;
    private final SandboxSecurityManager sandboxSecurityManager;
    private final ScriptSource scriptSource;

    public DefaultPipelineFactory(final PublishedPipelineRepository repository,
                                  final ConfigurationCompiler configCompiler,
                                  final PropertyResolver propertyResolver,
                                  final SandboxSecurityManager sandboxSecurityManager,
                                  final ScriptSource scriptSource) {
        this.repository = repository;
        this.configCompiler = configCompiler;
        this.propertyResolver = propertyResolver;
        this.sandboxSecurityManager = sandboxSecurityManager;
        this.scriptSource = scriptSource;
    }

    @Override
    public Pipeline getPipeline(
            final String pipelineCode,
            final String pipelineVersion) {

        final PublishedPipeline publishedPipeline = repository
                .findByCodeAndVersion(pipelineCode, pipelineVersion);

        if (publishedPipeline == null) {
            throw new NoSuchElementException(String.format(
                    "Unable to build pipeline. There is no pipeline definition for pipeline with code \"%s\" and version \"%s\"",
                    pipelineCode,
                    pipelineVersion
            ));
        }
        return createPipeline(publishedPipeline);
    }

    @Override
    public Pipeline getEffectivePipeline(
            final String pipelineCode,
            final String pipelineVersion) throws PipelineBuildException {

        final PublishedPipeline publishedPipeline = repository
                .findByCodeAndVersion(pipelineCode, pipelineVersion);

        return createPipeline(
                publishedPipeline != null
                        ? publishedPipeline
                        : PublishedPipeline.builder()
                        .pipelineCode(pipelineCode)
                        .version(pipelineVersion)
                        .scripts(getSystemScripts(pipelineCode))
                        .build()
        );
    }

    @Override
    public Pipeline getDevelopmentPipeline(
            final String pipelineCode,
            final String pipelineVersion,
            final String scriptBody) {

        return createPipeline(
                PublishedPipeline.builder()
                        .pipelineCode("Development Pipeline")
                        .scripts(newArrayList(
                                PublishedScript.builder()
                                        .type(User)
                                        .body(scriptBody)
                                        .build(),
                                scriptSource.loadScript(Base, pipelineCode)
                                        .orElseThrow(() -> new IllegalStateException(String.format(
                                                "No base script found for the \"%s\" pipeline",
                                                pipelineCode
                                        )))
                        ))
                        .build()
        );
    }

    private List<PublishedScript> getSystemScripts(final String pipelineCode) {
        // TODO remove code duplication with PublishedPipelineRepository
        return newArrayList(
                PublishedScript.builder().type(Base).build(),
                PublishedScript.builder().type(Pre).build(),
                PublishedScript.builder().type(Post).build()
        ).stream()
                .map(script -> script.copy()
                        .body(scriptSource.loadScript(script.getType(), pipelineCode)
                                .map(PublishedScript::getBody)
                                .orElse(null)
                        )
                        .build()
                )
                .filter(script -> script.getBody() != null)
                .collect(toList());
    }

    private Pipeline createPipeline(final PublishedPipeline publishedPipeline) throws PipelineBuildException {

        final PipelineDefinition pipelineDefinition = toPipelineDefinition(publishedPipeline);

        final ScriptCompiler scriptCompiler = toScriptCompiler(
                publishedPipeline.getScripts().stream()
                        .filter(script -> script.getType() == ScriptType.Base)
                        .findFirst()
                        .map(PublishedScript::getBody)
                        .orElseThrow(() -> new IllegalStateException(String.format(
                                "Pipeline has no base script configured: %s",
                                publishedPipeline
                        )))
        );

        final List<ScriptDefinition> nonBaseScripts = pipelineDefinition.getScripts().stream()
                .filter(script -> script.getSource().getType() != Base)
                .collect(toList());

        final List<ScriptDefinition> scriptDefinitions = new ArrayList<>();
        final Map<ScriptDefinition, Exception> buildErrors = new HashMap<>();

        // For each node, load and compile the code and configuration and report back any errors.
        for (final ScriptDefinition node : nonBaseScripts) {
            try {
                final ScriptInfo scriptInfo = new ScriptInfo(
                        node.getSource().getBody(),
                        Collections.emptyMap()
                );
                final Class<? extends PipelineScript> scriptClass = scriptCompiler.compile(scriptInfo.getCode());
                final Map<String, Object> configuration = configCompiler.compile(scriptInfo.getProperties());

                final ScriptDefinition.Builder builder = ScriptDefinition.builder()
                        .compiledScript(scriptClass)
                        .configuration(configuration)
                        .source(node.getSource());

                // Add property resolver to system scripts.
                final ScriptType type = node.getSource().getType();
                if (type == Pre || type == Post) {
                    builder.propertyResolver(propertyResolver);
                }
                scriptDefinitions.add(builder.build());

            } catch (final CompilationFailedException exception) {
                exception.fillInStackTrace();
                buildErrors.put(node, exception);
            }
        }

        if (!buildErrors.isEmpty()) {
            throw new PipelineBuildException(
                    String.format(
                            "Failed to build pipeline: %s v. %s",
                            publishedPipeline.getPipelineCode(),
                            publishedPipeline.getVersion()
                    ),
                    pipelineDefinition,
                    buildErrors
            );
        }

        return new Pipeline(pipelineDefinition, scriptDefinitions, sandboxSecurityManager);
    }

}
