package org.opentestsystem.rdw.script.impl;

import org.codehaus.groovy.control.CompilationFailedException;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.opentestsystem.rdw.script.ConfigurationCompiler;
import org.opentestsystem.rdw.script.Pipeline;
import org.opentestsystem.rdw.script.PipelineBuildException;
import org.opentestsystem.rdw.script.PipelineDefinition;
import org.opentestsystem.rdw.script.PipelineFactory;
import org.opentestsystem.rdw.script.PipelineScript;
import org.opentestsystem.rdw.script.PropertyResolver;
import org.opentestsystem.rdw.script.ScriptCompiler;
import org.opentestsystem.rdw.script.ScriptDefinition;
import org.opentestsystem.rdw.script.ScriptInfo;
import org.opentestsystem.rdw.script.ScriptSource;
import org.opentestsystem.rdw.script.AbstractPipelineResource;
import org.opentestsystem.rdw.script.security.SandboxSecurityManager;

import static java.util.Collections.singletonList;

/**
 * Factory class for creating a Pipeline by loading the pipeline definition and then using it to
 * load the script definitions for each node.
 */
public class DefaultPipelineFactory implements PipelineFactory {
    // Interface for loading the script base class code, the pipeline definition, and the script code.
    private final ScriptSource scriptSource;

    // Compiler of Groovy scripts into Java byte code.
    private final ScriptCompiler scriptCompiler;

    // Compiler of configuration properties, which may involve loading database connections and
    // other manipulations
    private final ConfigurationCompiler configCompiler;
    private final PropertyResolver propertyResolver;
    private final SandboxSecurityManager sandboxSecurityManager;

    public DefaultPipelineFactory(final ScriptSource scriptSource,
                                  final ScriptCompiler scriptCompiler,
                                  final ConfigurationCompiler configCompiler,
                                  final PropertyResolver propertyResolver,
                                  final SandboxSecurityManager sandboxSecurityManager) {
        this.scriptSource = scriptSource;
        this.scriptCompiler = scriptCompiler;
        this.configCompiler = configCompiler;
        this.propertyResolver = propertyResolver;
        this.sandboxSecurityManager = sandboxSecurityManager;
    }

    /**
     * Creates a runnable pipeline by loading and compiling the scripts.
     *
     * @param pipelineName    the name of the pipeline to create
     * @param pipelineVersion the version of the pipeline
     * @return a fully compiled pipeline that can be run against input files
     * @throws PipelineBuildException if any part of the pipeline couldn't be loaded or compiled.
     */
    @Override
    public Pipeline getPipeline(final String pipelineName, final String pipelineVersion)
            throws PipelineBuildException {
        final PipelineDefinition pipelineDefinition = scriptSource.loadPipelineDefinition(pipelineName, pipelineVersion);

        final List<ScriptDefinition> scriptDefinitions = new ArrayList<>();
        final Map<AbstractPipelineResource, Exception> buildErrors = new HashMap<>();

        // For each node, load and compile the code and configuration and report back any errors.
        for (final ScriptDefinition node : pipelineDefinition.getScripts()) {
            try {
                final ScriptInfo scriptInfo = scriptSource.loadScript(node);
                final Class<? extends PipelineScript> scriptClass =
                        scriptCompiler.compile(scriptInfo.getCode(), node.getName());
                final Map<String, Object> configuration = configCompiler.compile(scriptInfo.getProperties());

                scriptDefinitions.add(
                        ScriptDefinition.builder()
                                .name(node.getName())
                                .version(node.getVersion())
                                .userCreated(node.isUserCreated())
                                .compiledScript(scriptClass)
                                .configuration(configuration)
                                .propertyResolver(propertyResolver)
                                .build());
            } catch (final CompilationFailedException exception) {
                exception.fillInStackTrace();
                buildErrors.put(node, exception);
            }
        }

        if (!buildErrors.isEmpty()) {
            throw new PipelineBuildException(
                    "Failed to build pipeline: " + pipelineName + " v. " + pipelineVersion,
                    pipelineDefinition, buildErrors);
        }

        return new Pipeline(pipelineDefinition, scriptDefinitions, sandboxSecurityManager);
    }

    /**
     * Creates an ad-hoc but runnable pipeline for testing a script during development.
     *
     * @param scriptBody the code of the user developed script
     * @return a fully compiled pipeline that can be run against input files
     * @throws PipelineBuildException if any part of the pipeline couldn't be loaded or compiled.
     */
    @Override
    public Pipeline getDevelopmentPipeline(final String scriptBody) {
        final String pipelineName = "Pipeline Test";
        final String scriptName = "user_script_test";
        final String version = "test";

        final PipelineDefinition pipelineDefinition = PipelineDefinition.builder()
                .name(pipelineName)
                .version(version)
                .scripts(singletonList(
                        ScriptDefinition.builder()
                                .name(scriptName)
                                .version(version)
                                .userCreated(true)
                                .build()
                ))
                .rollbackVersion("N/A")
                .build();

        final Class<? extends PipelineScript> scriptClass =
                scriptCompiler.compile(scriptBody, scriptName);

        final Map<String, Object> configuration = Collections.emptyMap();

        final ScriptDefinition scriptDefinition = ScriptDefinition.builder()
                .name(scriptName)
                .version("test")
                .userCreated(true)
                .compiledScript(scriptClass)
                .configuration(configuration)
                .propertyResolver(propertyResolver)
                .build();

        return new Pipeline(pipelineDefinition, singletonList(scriptDefinition), sandboxSecurityManager);
    }
}
