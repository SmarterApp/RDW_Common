package org.opentestsystem.rdw.script.impl;

import org.codehaus.groovy.control.CompilationFailedException;
import org.opentestsystem.rdw.script.ConfigurationCompiler;
import org.opentestsystem.rdw.script.Pipeline;
import org.opentestsystem.rdw.script.PipelineBuildException;
import org.opentestsystem.rdw.script.PipelineDefinition;
import org.opentestsystem.rdw.script.PipelineFactory;
import org.opentestsystem.rdw.script.PipelineScript;
import org.opentestsystem.rdw.script.PropertyResolver;
import org.opentestsystem.rdw.script.ScriptCompiler;
import org.opentestsystem.rdw.script.ScriptCompilers;
import org.opentestsystem.rdw.script.ScriptDefinition;
import org.opentestsystem.rdw.script.ScriptInfo;
import org.opentestsystem.rdw.script.ScriptSource;
import org.opentestsystem.rdw.script.publishing.PublishedPipeline;
import org.opentestsystem.rdw.script.publishing.PublishedScript;
import org.opentestsystem.rdw.script.publishing.ScriptType;
import org.opentestsystem.rdw.script.security.SandboxSecurityManager;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static com.google.common.collect.Lists.newArrayList;
import static java.util.stream.Collectors.toList;

/**
 * Factory class for creating a Pipeline by loading the pipeline definition and then using it to
 * load the script definitions for each node.
 */
public class DefaultPipelineFactory implements PipelineFactory {
    // Interface for loading the script base class code, the pipeline definition, and the script code.
    private final ScriptSource scriptSource;

    // Compiler of configuration properties, which may involve loading database connections and
    // other manipulations
    private final ConfigurationCompiler configCompiler;
    private final PropertyResolver propertyResolver;
    private final SandboxSecurityManager sandboxSecurityManager;
    private final String defaultBaseScript;

    public DefaultPipelineFactory(final ScriptSource scriptSource,
                                  final ConfigurationCompiler configCompiler,
                                  final PropertyResolver propertyResolver,
                                  final SandboxSecurityManager sandboxSecurityManager,
                                  final String defaultBaseScript) {
        this.scriptSource = scriptSource;
        this.configCompiler = configCompiler;
        this.propertyResolver = propertyResolver;
        this.sandboxSecurityManager = sandboxSecurityManager;
        this.defaultBaseScript = defaultBaseScript != null ? defaultBaseScript : "";
    }

    @Override
    public Pipeline getPipeline(final String pipelineCode, final String pipelineVersion) throws PipelineBuildException {
        final PipelineDefinition pipelineDefinition = scriptSource.loadPipelineDefinition(pipelineCode, pipelineVersion);

        final String baseScript = pipelineDefinition.getSource().getScripts().stream()
                .filter(script -> script.getType() == ScriptType.Base)
                .findFirst()
                .map(PublishedScript::getBody)
                .orElse(defaultBaseScript);

        final ScriptCompiler scriptCompiler = ScriptCompilers.create(baseScript);

        final List<ScriptDefinition> nonBaseScripts = pipelineDefinition.getScripts().stream()
                .filter(script -> script.getSource().getType() != ScriptType.Base)
                .collect(toList());

        final List<ScriptDefinition> scriptDefinitions = new ArrayList<>();
        final Map<ScriptDefinition, Exception> buildErrors = new HashMap<>();

        // For each node, load and compile the code and configuration and report back any errors.
        for (final ScriptDefinition node : nonBaseScripts) {
            try {
                final ScriptInfo scriptInfo = scriptSource.loadScript(node);
                final Class<? extends PipelineScript> scriptClass =
                        scriptCompiler.compile(scriptInfo.getCode());
                final Map<String, Object> configuration = configCompiler.compile(scriptInfo.getProperties());

                scriptDefinitions.add(
                        ScriptDefinition.builder()
                                .compiledScript(scriptClass)
                                .configuration(configuration)
                                .propertyResolver(propertyResolver)
                                .source(node.getSource())
                                .build());
            } catch (final CompilationFailedException cfe) {
                cfe.fillInStackTrace();
                buildErrors.put(node, cfe);
            }
        }

        if (!buildErrors.isEmpty()) {
            throw new PipelineBuildException(
                    "Failed to build pipeline: " + pipelineCode + " v. " + pipelineVersion,
                    pipelineDefinition, buildErrors);
        }

        return new Pipeline(pipelineDefinition, scriptDefinitions, sandboxSecurityManager);
    }

    @Override
    public Pipeline getDevelopmentPipeline(final String pipelineCode, final String pipelineVersion, final String scriptBody) {

        final ScriptCompiler scriptCompiler = ScriptCompilers.create(
                scriptSource.loadPipelineDefinition(pipelineCode, pipelineVersion)
                        .getSource().getScripts().stream()
                        .filter(script -> script.getType() == ScriptType.Base)
                        .findFirst()
                        .map(PublishedScript::getBody)
                        .orElse(defaultBaseScript)
        );

        final PublishedPipeline pipeline = PublishedPipeline.builder()
                .pipelineCode("Development Pipeline")
                .scripts(newArrayList(
                        PublishedScript.builder()
                                .type(ScriptType.User)
                                .body(scriptBody)
                                .build()
                ))
                .build();

        // map to runnable
        final List<ScriptDefinition> scripts = newArrayList(
                ScriptDefinition.builder()
                        .source(pipeline.getScripts().get(0))
                        .compiledScript(scriptCompiler.compile(scriptBody))
                        .propertyResolver(propertyResolver)
                        .build()
        );

        final PipelineDefinition pipelineDefinition = PipelineDefinition.builder()
                .source(pipeline)
                .scripts(scripts)
                .build();

        // TODO can't the scripts just be extracted from the pipeline directly?
        return new Pipeline(pipelineDefinition, scripts, sandboxSecurityManager);
    }


}
