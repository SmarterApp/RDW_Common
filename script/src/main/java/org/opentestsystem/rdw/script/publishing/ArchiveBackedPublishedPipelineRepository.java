
package org.opentestsystem.rdw.script.publishing;

import org.springframework.stereotype.Repository;

import java.time.Instant;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.Properties;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.opentestsystem.rdw.archive.ArchiveService;
import org.opentestsystem.rdw.script.ScriptSource;

import static java.nio.charset.StandardCharsets.UTF_8;
import static java.util.stream.Collectors.toList;
import static org.opentestsystem.rdw.script.publishing.ScriptType.Base;
import static org.opentestsystem.rdw.script.publishing.ScriptType.Post;
import static org.opentestsystem.rdw.script.publishing.ScriptType.Pre;
import static org.opentestsystem.rdw.script.publishing.ScriptType.User;

/**
 * Published pipeline repository implementation that stores the published pipelines using an archive service
 * <p>
 * The address structure for pipeline resources is organized as follows:
 * <p>
 * /{bucket}
 *  /pipelines
 *   /{pipelineCode} (assessment|exam|group)
 *    pipeline.{version}.json
 *    user.{version}.groovy
 *    base.{version}.groovy
 *    pre-process.{version}.groovy
 *    post-process.{version}.groovy
 */
@Repository
public class ArchiveBackedPublishedPipelineRepository implements PublishedPipelineRepository {

    private final ArchiveService archiveService;
    private final ScriptSource scriptSource;

    public ArchiveBackedPublishedPipelineRepository(
            final ArchiveService archiveService,
            final ScriptSource scriptSource) {
        this.archiveService = archiveService;
        this.scriptSource = scriptSource;
    }

    @Override
    public List<PublishedPipeline> findAllByCode(final String code) {
        return archiveService.listResources(toPipelinesPathPrefix(code)).stream()
                .filter(path -> path.endsWith(".groovy"))
                .map(scriptPath -> {
                    final Properties properties = findProperties(scriptPath);
                    final String version = parseVersion(scriptPath);
                    return PublishedPipeline.builder()
                            .pipelineCode(code)
                            .version(version)
                            .published(Instant.parse(properties.getProperty("published")))
                            .publishedBy(properties.getProperty("publishedBy"))
                            .build();
                })
                .collect(toList());
    }

    @Override
    public PublishedPipeline findByCodeAndVersion(final String code, final String version) {
        final List<PublishedScript> scripts = new ArrayList<>();
        findUserScript(code, version).ifPresent(scripts::add);

        scriptSource.loadScript(Base, code).ifPresent(scripts::add);
        scriptSource.loadScript(Pre, code).ifPresent(scripts::add);
        scriptSource.loadScript(Post, code).ifPresent(scripts::add);

        final Properties publishedProperties = findProperties(code, version);
        Instant published = null;
        try {
            published = Instant.parse(publishedProperties.getProperty("published"));
        } catch (Exception e) {
            // TODO: log
        }

        final String publishedBy = publishedProperties.getProperty("publishedBy");

        return PublishedPipeline.builder()
                .pipelineCode(code)
                .version(version)
                .scripts(scripts)
                .published(published)
                .publishedBy(publishedBy)
                .build();
    }

    @Override
    public PublishedPipeline create(final PublishedPipeline pipeline) {

        final String nextVersion = Integer.toString(
                findAllByCode(pipeline.getPipelineCode())
                        .stream()
                        .mapToInt(published -> Integer.parseInt(published.getVersion()))
                        .max().orElse(0) + 1
        );

        final PublishedPipeline published = pipeline.copy()
                .version(nextVersion)
                .published(Instant.now())
                .build();

        final Properties properties = new Properties();
        Optional.ofNullable(pipeline.getPublishedBy()).ifPresent(user ->
                properties.setProperty("publishedBy", user));
        Optional.ofNullable(pipeline.getPublished()).ifPresent(instant ->
                properties.setProperty("published", instant.toString()));

        pipeline.getScripts().stream()
                .filter(script -> script.getType() == User)
                .findFirst()
                .ifPresent(publishedScript -> archiveService.writeResource(
                        toUserScriptPath(published.getPipelineCode(), published.getVersion()),
                        publishedScript.getBody().getBytes(UTF_8),
                        properties
                ));

        return published;
    }

    /**
     * Finds the script for the specified type, pipeline and version
     *
     * @param pipelineCode The pipeline identifier
     * @param version The script version (this can be the pipeline version in the case of the user script)
     * @return The published script for the given type, pipeline and version
     */
    private Optional<PublishedScript> findUserScript(final String pipelineCode, final String version) {
        final String path = toUserScriptPath(pipelineCode, version);
        if (archiveService.exists(path)) {
            return Optional.of(
                    PublishedScript.builder()
                            .type(User)
                            .version(version)
                            .body(readArchiveResourceAsString(path))
                            .build()
            );
        }
        return Optional.empty();
    }

    private static String toPipelinesPathPrefix(final String pipelineCode) {
        return String.format(
                "pipelines/%s",
                pipelineCode
        );
    }

    private static String toUserScriptPath(final String code, final String version) {
        return String.format("pipelines/%s/user.%s.groovy", code, version);
    }

    private static String parseVersion(final String path) {
        final Pattern pattern = Pattern.compile("user\\.(.+)\\.groovy");
        final Matcher matcher = pattern.matcher(path);
        if (matcher.find()) {
            return matcher.group(1);
        }

        return "";
    }

    private Properties findProperties(final String pipelineCode, final String version) {
        final String path = toUserScriptPath(pipelineCode, version);
        return findProperties(path);
    }

    private Properties findProperties(final String path) {
        try {
            return archiveService.readProperties(path);
        } catch (IllegalArgumentException e) {
            return new Properties();
        }
    }

    private String readArchiveResourceAsString(final String location) {
        return new String(archiveService.readResource(location), UTF_8);
    }
}