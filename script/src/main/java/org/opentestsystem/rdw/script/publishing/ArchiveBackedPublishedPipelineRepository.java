package org.opentestsystem.rdw.script.publishing;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.opentestsystem.rdw.archive.ArchiveService;
import org.springframework.stereotype.Service;

import java.io.IOException;
import java.time.Instant;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.Properties;

import static java.nio.charset.StandardCharsets.UTF_8;
import static java.util.stream.Collectors.toList;
import static org.opentestsystem.rdw.script.publishing.ScriptType.Pre;
import static org.opentestsystem.rdw.script.publishing.ScriptType.User;
import static org.opentestsystem.rdw.script.publishing.ScriptType.Post;
import static org.opentestsystem.rdw.script.publishing.ScriptType.Base;

/**
 * Published pipeline repository implementation that stores the published pipelines using an archive service
 *
 * The address structure for pipeline resources is organized as follows:
 * <p>
 * /{bucket}
 *  /pipelines
 *   /{pipelineCode} (assessment|exam|group)
 *    /user
 *     /{version}
 *      pipeline.json
 *      user-script.groovy
 *    /system
 *     /base-script
 *      /{version}
 *        base-script.groovy
 *     /pre-process
 *      /{version}
 *        pre-process.groovy
 *     /post-process
 *      /{version}
 *       post-process.groovy
 */
@Service
public class ArchiveBackedPublishedPipelineRepository implements PublishedPipelineRepository {

    private static String toPipelinesPathPrefix(final String pipelineCode) {
        return String.format(
                "pipelines/%s",
                pipelineCode
        );
    }

    private static String toPipelinePath(final String pipelineCode, final int pipelineVersion) {
        return String.format(
                "pipelines/%s/user/%s/pipeline.json",
                pipelineCode,
                pipelineVersion
        );
    }

    private static String toUserScriptPath(final String pipelineCode, final int pipelineVersion) {
        return String.format(
                "pipelines/%s/user/%s/user-script.groovy",
                pipelineCode,
                pipelineVersion
        );
    }

    private static String toBaseScriptPath(final String pipelineCode, final int version) {
        return String.format(
                "pipelines/%s/system/base-script/%s/base-script.groovy",
                pipelineCode,
                version
        );
    }

    private static String toPreScriptPath(final String pipelineCode, final int version) {
        return String.format(
                "pipelines/%s/system/pre-process/%s/pre-process.groovy",
                pipelineCode,
                version
        );
    }

    private static String toPostScriptPath(final String pipelineCode, final int version) {
        return String.format(
                "pipelines/%s/system/post-process/%s/post-process.groovy",
                pipelineCode,
                version
        );
    }

    private final ArchiveService archiveService;
    private final ObjectMapper objectMapper;

    public ArchiveBackedPublishedPipelineRepository(
            final ArchiveService archiveService,
            final ObjectMapper objectMapper) {
        this.archiveService = archiveService;
        this.objectMapper = objectMapper;
    }

    @Override
    public List<PublishedPipeline> findAllByCode(final String code) {
        return archiveService.listResources(toPipelinesPathPrefix(code)).stream()
                .filter(path -> path.endsWith("pipeline.json"))
                .map(pipelineResourcePath -> {
                    final PipelineResource resource = deserialize(
                            archiveService.readResource(pipelineResourcePath),
                            PipelineResource.class
                    );
                    return PublishedPipeline.builder()
                            .pipelineCode(resource.getPipelineCode())
                            .version(resource.getVersion())
                            .published(resource.getPublished())
                            .publishedBy(resource.getPublishedBy())
                            .build();
                })
                .collect(toList());
    }

    @Override
    public PublishedPipeline findByCodeAndVersion(final String code, final int version) {
        final PipelineResource resource = deserialize(
                archiveService.readResource(
                        toPipelinePath(code, version)
                ),
                PipelineResource.class
        );

        final List<PublishedScript> scripts = new ArrayList<>();
        findUserScript(resource.getPipelineCode(), resource.getVersion()).ifPresent(scripts::add);
        scripts.add(findBaseScript(resource.getPipelineCode(), resource.getBaseScriptVersion()));
        scripts.add(findPreScript(resource.getPipelineCode(), resource.getPreProcessScriptVersion()));
        scripts.add(findPostScript(resource.getPipelineCode(), resource.getPostProcessScriptVersion()));

        return PublishedPipeline.builder()
                .pipelineCode(resource.getPipelineCode())
                .version(resource.getVersion())
                .scripts(scripts)
                .published(resource.getPublished())
                .publishedBy(resource.getPublishedBy())
                .build();
    }

    @Override
    public PublishedPipeline create(final PublishedPipeline pipeline) {

        final int nextVersion = findAllByCode(pipeline.getPipelineCode())
                .stream()
                .mapToInt(PublishedPipeline::getVersion)
                .max().orElse(0) + 1;

        final PublishedPipeline published = pipeline.copy()
                .version(nextVersion)
                .published(Instant.now())
                .build();

        // TODO current versions of system scripts should be looked up here
        // how do i select these? latest always? current config repo props?
        final Integer baseScriptVersion = 1;
        final Integer preProcessScriptVersion = 1;
        final Integer postProcessScriptVersion = 1;

        final PipelineResource pipelineResource = PipelineResource.builder()
                .pipelineCode(published.getPipelineCode())
                .version(published.getVersion())
                .published(pipeline.getPublished())
                .publishedBy(pipeline.getPublishedBy())
                .baseScriptVersion(baseScriptVersion)
                .preProcessScriptVersion(preProcessScriptVersion)
                .postProcessScriptVersion(postProcessScriptVersion)
                .build();

        archiveService.writeResource(
                toPipelinePath(published.getPipelineCode(), published.getVersion()),
                serialize(pipelineResource),
                new Properties()
        );

        pipeline.getScripts().stream()
                .filter(script -> script.getType() == User)
                .findFirst()
                .ifPresent(publishedScript -> archiveService.writeResource(
                        toUserScriptPath(published.getPipelineCode(), published.getVersion()),
                        publishedScript.getBody().getBytes(UTF_8),
                        new Properties()
                ));

        return published;
    }

    private Optional<PublishedScript> findUserScript(final String pipelineCode, final int pipelineVersion) {
        final String userScriptPath = toUserScriptPath(
                pipelineCode,
                pipelineVersion
        );
        if (archiveService.exists(userScriptPath)) {
            return Optional.of(
                    PublishedScript.builder()
                            .type(User)
                            .version(pipelineVersion)
                            .body(archiveService.readResourceAsString(userScriptPath))
                            .build()
            );
        }
        return Optional.empty();
    }

    private PublishedScript findBaseScript(final String pipelineCode, final int version) {
        return PublishedScript.builder()
                .type(Base)
                .version(version)
                .body(archiveService.readResourceAsString(
                        toBaseScriptPath(
                                pipelineCode,
                                version
                        )
                ))
                .build();
    }

    private PublishedScript findPreScript(final String pipelineCode, final int version) {
        return PublishedScript.builder()
                .type(Pre)
                .version(version)
                .body(archiveService.readResourceAsString(
                        toPreScriptPath(
                                pipelineCode,
                                version
                        )
                ))
                .build();
    }

    private PublishedScript findPostScript(final String pipelineCode, final int version) {
        return PublishedScript.builder()
                .type(Post)
                .version(version)
                .body(archiveService.readResourceAsString(
                        toPostScriptPath(
                                pipelineCode,
                                version
                        )
                ))
                .build();
    }

    /**
     * Serializes the provided value or throws a runtime exception if it fails
     *
     * @param value The object to serialize
     * @return The serialized object
     * @throws RuntimeException if the serialization fails
     */
    private byte[] serialize(final Object value) {
        try {
            return objectMapper.writeValueAsBytes(value);
        } catch (final JsonProcessingException exception) {
            throw new RuntimeException(exception);
        }
    }

    /**
     * Serializes the provided value or throws a runtime exception if it fails
     *
     * @param value The object to deserialize
     * @param type  The object type to deserialize to
     * @return The deserialized object
     * @throws RuntimeException if the deserialization fails
     */
    private <T> T deserialize(final byte[] value, final Class<T> type) {
        try {
            return objectMapper.readValue(value, type);
        } catch (final IOException exception) {
            throw new RuntimeException(exception);
        }
    }

}
