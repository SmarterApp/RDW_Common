
package org.opentestsystem.rdw.script.publishing;

import org.opentestsystem.rdw.archive.ArchiveService;
import org.springframework.stereotype.Repository;

import java.time.Instant;
import java.util.List;
import java.util.Optional;
import java.util.Properties;
import java.util.regex.Pattern;

import static com.google.common.collect.Lists.newArrayList;
import static java.nio.charset.StandardCharsets.UTF_8;
import static java.util.stream.Collectors.toList;
import static org.opentestsystem.rdw.script.publishing.PublishedPipelines.toProperties;
import static org.opentestsystem.rdw.script.publishing.PublishedPipelines.toPublishedPipeline;
import static org.opentestsystem.rdw.script.publishing.ScriptType.User;

/**
 * Published pipeline repository implementation that stores the published pipelines using an archive service
 * <p>
 * The address structure for pipeline resources is organized as follows:
 * <p>
 * /{bucket}
 *  /pipelines
 *   /{pipelineCode} (assessment|exam|group)
 *    user.{version}.groovy
 */
@Repository
public class ArchiveBackedPublishedPipelineRepository implements PublishedPipelineRepository {

    private static final Pattern UserScriptPattern = Pattern.compile("^(.*?)user\\.(\\d+)\\.groovy$");

    private final ArchiveService archiveService;

    public ArchiveBackedPublishedPipelineRepository(final ArchiveService archiveService) {
        this.archiveService = archiveService;
    }

    @Override
    public List<PublishedPipeline> findAllByCode(final String code) {
        return archiveService.listResources(toPipelinesPathPrefix(code)).stream()
                .filter(path -> UserScriptPattern.matcher(path).matches())
                .map(scriptPath -> toPublishedPipeline(
                        findProperties(scriptPath)
                ))
                .collect(toList());
    }

    @Override
    public PublishedPipeline findByCodeAndVersion(final String code, final String version) {
        try {
            return toPublishedPipeline(findUserScriptProperties(code, version)).copy()
                    .scripts(newArrayList(
                            PublishedScript.builder()
                                    .type(User)
                                    .version(version)
                                    .body(readArchiveResourceAsString(
                                            toUserScriptPath(code, version)
                                    ))
                                    .build()
                    ))
                    .build();
        } catch (final Exception exception) {
            return null;
        }
    }

    @Override
    public PublishedPipeline create(final PublishedPipeline pipeline) {

        final String nextVersion = Integer.toString(
                findAllByCode(pipeline.getPipelineCode())
                        .stream()
                        .mapToInt(published -> Integer.parseInt(published.getVersion()))
                        .max()
                        .orElse(0)
                        + 1
        );

        final PublishedPipeline published = pipeline.copy()
                .version(nextVersion)
                .published(Instant.now())
                .build();

        published.getScripts().stream()
                .filter(script -> script.getType() == User)
                .findFirst()
                .ifPresent(publishedScript -> archiveService.writeResource(
                        toUserScriptPath(published.getPipelineCode(), published.getVersion()),
                        publishedScript.getBody().getBytes(UTF_8),
                        toProperties(published)
                ));

        return published;
    }

    private static String toPipelinesPathPrefix(final String pipelineCode) {
        return String.format("pipelines/%s", pipelineCode);
    }

    private static String toUserScriptPath(final String code, final String version) {
        return String.format("pipelines/%s/user.%s.groovy", code, version);
    }

    private Properties findUserScriptProperties(final String pipelineCode, final String version) {
        return findProperties(
                toUserScriptPath(pipelineCode, version)
        );
    }

    /**
     * TODO change archive service to return optional for read calls
     *
     * @throws Exception if properties are missing
     */
    private Properties findProperties(final String path) {
        return archiveService.readProperties(path);
    }

    /**
     * TODO change archive service to return optional for read calls
     *
     * @throws Exception if the resource is missing
     */
    private String readArchiveResourceAsString(final String location) {
        return new String(archiveService.readResource(location), UTF_8);
    }

}
