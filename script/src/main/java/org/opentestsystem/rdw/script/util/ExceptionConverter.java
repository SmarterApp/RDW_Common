package org.opentestsystem.rdw.script.util;

import groovy.lang.GroovyRuntimeException;
import org.codehaus.groovy.control.CompilationFailedException;
import org.codehaus.groovy.control.MultipleCompilationErrorsException;
import org.codehaus.groovy.control.messages.Message;
import org.codehaus.groovy.control.messages.SyntaxErrorMessage;
import org.codehaus.groovy.syntax.SyntaxException;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import org.opentestsystem.rdw.script.ScriptRuntimeException;

/**
 * Converters for various script exceptions into ScriptError objects for consumption by front-end services.
 */
public class ExceptionConverter {

    /**
     * Convert a GroovyRuntimeException to ScriptError using the row and column information from the AST Node
     * if available.
     * @param e the GroovyRuntimeException
     * @return a ScriptError populated with the exception's message and row and column information if available.
     */
    public static ScriptError convert(final GroovyRuntimeException e) {
        return (e.getNode() == null) ?
                new ScriptError(e.getMessage(), null, null) :
                new ScriptError(e.getMessage(), e.getNode().getLineNumber(), e.getNode().getColumnNumber());
    }

    /**
     * Convert a ScriptRuntimeException, which is thrown for any runtime errors in a PipelineScript.
     *
     * @param e the ScriptRuntimeException
     * @return a ScriptError populated with the error message and script line number. Column will always be null.
     */
    public static ScriptError convert(final ScriptRuntimeException e) {
        return new ScriptError(e.getOriginalMessage(), e.getLineNumber(), null);
    }

    /**
     * Convert a CompilationFailedException, which wraps one or more compilation errors.
     * @param e the CompilationFailedException
     * @return List of ScriptErrors, populated with the compile error messages, start lines, and start columns
     */
    public static List<ScriptError> convert(final CompilationFailedException e) {
        if (e instanceof MultipleCompilationErrorsException) {
            return convert((MultipleCompilationErrorsException)e);
        } else {
            return Collections.singletonList(convert((GroovyRuntimeException)e));
        }
    }

    private static List<ScriptError> convert(final MultipleCompilationErrorsException e) {
        if (e.getErrorCollector() == null
                || e.getErrorCollector().getErrors() == null
                || e.getErrorCollector().getErrors().isEmpty())
        {
            return Collections.singletonList(convert((GroovyRuntimeException) e));
        }

        final List<ScriptError> errorsList = new ArrayList<>();

        for (Object error : e.getErrorCollector().getErrors()) {
            if (error instanceof SyntaxErrorMessage) {
                SyntaxException exception = ((SyntaxErrorMessage) error).getCause();
                errorsList.add(convert(exception));
            } else if (error instanceof Message) {
                Message message = (Message)error;
                final StringWriter stringWriter = new StringWriter();
                message.write(new PrintWriter(stringWriter));
                errorsList.add(new ScriptError(stringWriter.toString(), null, null));
            }
        }

        return errorsList;
    }

    private static ScriptError convert(SyntaxException e) {
        return new ScriptError(e.getOriginalMessage(), e.getStartLine(), e.getStartColumn());
    }
}
