package org.opentestsystem.rdw.script;

import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;
import org.opentestsystem.rdw.script.impl.DefaultPipelineFactory;
import org.opentestsystem.rdw.script.publishing.PublishedPipelineRepository;
import org.opentestsystem.rdw.script.security.SandboxSecurityManager;

import java.util.Arrays;
import java.util.Optional;

import static com.google.common.collect.Lists.newArrayList;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.when;
import static org.opentestsystem.rdw.script.PipelineScriptType.Post;
import static org.opentestsystem.rdw.script.PipelineScriptType.Pre;
import static org.opentestsystem.rdw.script.util.Tests.resourceAsString;

@RunWith(MockitoJUnitRunner.class)
public class DefaultPipelineFactoryTest {

    private static final PipelineScriptDefinition NonCompilingScript = PipelineScriptDefinition.builder()
            .body("new NoSuchThing()")
            .build();

    @Mock
    private PublishedPipelineRepository repository;

    @Mock
    private ConfigurationCompiler configurationCompiler;

    @Mock
    private PropertyResolver propertyResolver;

    @Mock
    private SandboxSecurityManager sandboxSecurityManager;

    @Mock
    private ScriptSource scriptSource;

    @Rule
    public ExpectedException exception = ExpectedException.none();

    private PipelineFactory factory;
    private PipelineDefinition pipelineDefinition;
    private PipelineScriptDefinition userScript;
    private PipelineScriptDefinition baseScript;
    private PipelineScriptDefinition preScript;
    private PipelineScriptDefinition postScript;

    @Before
    public void before() throws Exception {

        final String pipelineVersion = "v";

        userScript = PipelineScriptDefinition.builder()
                .type(PipelineScriptType.User)
                .body("")
                .version(pipelineVersion)
                .build();
        baseScript = PipelineScriptDefinition.builder()
                .type(PipelineScriptType.Base)
                .body(resourceAsString("/scripts/DSLScriptBase.groovy"))
                .build();
        preScript = PipelineScriptDefinition.builder()
                .type(Pre)
                .body("pre script body")
                .build();
        postScript = PipelineScriptDefinition.builder()
                .type(Post)
                .body("post script body")
                .build();

        pipelineDefinition = PipelineDefinition.builder()
                .pipelineCode("test")
                .version(pipelineVersion)
                .scripts(Arrays.asList(
                        userScript
                ))
                .build();

        factory = new DefaultPipelineFactory(
                repository,
                configurationCompiler,
                propertyResolver,
                sandboxSecurityManager,
                scriptSource
        );


        when(scriptSource.getScript(PipelineScriptType.Base, pipelineDefinition.getPipelineCode()))
                .thenReturn(Optional.of(baseScript));

        when(scriptSource.getScript(Pre, pipelineDefinition.getPipelineCode()))
                .thenReturn(Optional.of(preScript));

        when(scriptSource.getScript(Post, pipelineDefinition.getPipelineCode()))
                .thenReturn(Optional.of(postScript));
    }

    @Test
    public void getPipelineShouldComposeAPipelineFromAPublishedPipeline() {

        when(repository.findByCodeAndVersion(pipelineDefinition.getPipelineCode(), pipelineDefinition.getVersion()))
                .thenReturn(pipelineDefinition);

        final Pipeline pipeline = factory.getPipeline(pipelineDefinition.getPipelineCode(), pipelineDefinition.getVersion());
        assertThat(pipeline.getSource())
                .isEqualToComparingFieldByFieldRecursively(
                        pipelineDefinition.copy()
                                .scripts(Arrays.asList(
                                        userScript,
                                        baseScript,
                                        preScript,
                                        postScript
                                ))
                );
    }

    @Test
    public void getPipelineShouldComposeAPipelineFromSystemScriptsWhenAPublishedPipelineIsAbsent() {
        final Pipeline pipeline = factory.getPipeline(pipelineDefinition.getPipelineCode(), null);
        assertThat(pipeline.getSource())
                .isEqualToComparingFieldByFieldRecursively(
                        pipelineDefinition.copy()
                                .version(null)
                                .scripts(Arrays.asList(
                                        baseScript,
                                        preScript,
                                        postScript
                                ))
                                .build()
                );
    }

    @Test
    public void getPipelineShouldAddSystemScriptsOnlyWhenPresent() {

        when(scriptSource.getScript(Pre, pipelineDefinition.getPipelineCode()))
                .thenReturn(Optional.empty());

        when(scriptSource.getScript(Post, pipelineDefinition.getPipelineCode()))
                .thenReturn(Optional.empty());

        final Pipeline pipeline = factory.getPipeline(pipelineDefinition.getPipelineCode(), null);
        assertThat(pipeline.getSource())
                .isEqualToComparingFieldByFieldRecursively(
                        pipelineDefinition.copy()
                                .version(null)
                                .scripts(newArrayList(
                                        baseScript
                                ))
                                .build()
                );
    }

    @Test(expected = IllegalStateException.class)
    public void getPipelineShouldThrowExceptionWhenBaseClassIsNotConfigured() {

        when(scriptSource.getScript(PipelineScriptType.Base, pipelineDefinition.getPipelineCode()))
                .thenReturn(Optional.empty());

        factory.getPipeline(pipelineDefinition.getPipelineCode(), null);
    }

    @Test(expected = IllegalArgumentException.class)
    public void getPipelineShouldThrowExceptionWhenVersionIsSpecifiedByAPipelineOfThatVersionIsNotFound() {
        factory.getPipeline(pipelineDefinition.getPipelineCode(), pipelineDefinition.getVersion());
    }

    @Test
    public void getPipelineShouldCorrectlyCompileAndComposeAllNonBaseScripts() {
        when(repository.findByCodeAndVersion(pipelineDefinition.getPipelineCode(), pipelineDefinition.getVersion()))
                .thenReturn(pipelineDefinition);

        final Pipeline pipeline = factory.getPipeline(pipelineDefinition.getPipelineCode(), pipelineDefinition.getVersion());

        // base script is not included
        assertThat(pipeline.getScripts().size()).isEqualTo(3);

        for (final PipelineScript script : pipeline.getScripts()) {
            assertThat(script.getSource()).isNotNull();
//            assertThat(script.getCompiledScript()).isNotNull();
//
//            final PipelineScriptType type = script.getSource().getType();
//            if (type == Pre || type == Post) {
//                assertThat(script.getPropertyResolver()).isNotNull();
//            }
        }

    }

    @Test(expected = PipelineBuildException.class)
    public void getPipelineShouldThrowExceptionWhenUserScriptDoesntCompile() {
        when(repository.findByCodeAndVersion(pipelineDefinition.getPipelineCode(), pipelineDefinition.getVersion()))
                .thenReturn(pipelineDefinition.copy()
                        .scripts(newArrayList(
                                NonCompilingScript
                        ))
                        .build()
                );

        factory.getPipeline(pipelineDefinition.getPipelineCode(), pipelineDefinition.getVersion());
    }

    @Test(expected = PipelineBuildException.class)
    public void getPipelineShouldThrowExceptionWhenBaseScriptDoesntCompile() {
        when(scriptSource.getScript(PipelineScriptType.Base, pipelineDefinition.getPipelineCode()))
                .thenReturn(Optional.of(NonCompilingScript));

        factory.getPipeline(pipelineDefinition.getPipelineCode(), null);
    }

    @Test(expected = PipelineBuildException.class)
    public void getPipelineShouldThrowExceptionWhenPreScriptDoesntCompile() {
        when(scriptSource.getScript(Pre, pipelineDefinition.getPipelineCode()))
                .thenReturn(Optional.of(NonCompilingScript));

        factory.getPipeline(pipelineDefinition.getPipelineCode(), null);
    }

    @Test(expected = PipelineBuildException.class)
    public void getPipelineShouldThrowExceptionWhenPostScriptDoesntCompile() {
        when(scriptSource.getScript(Post, pipelineDefinition.getPipelineCode()))
                .thenReturn(Optional.of(NonCompilingScript));

        factory.getPipeline(pipelineDefinition.getPipelineCode(), null);
    }



}
