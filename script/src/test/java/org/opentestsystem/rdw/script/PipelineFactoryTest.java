package org.opentestsystem.rdw.script;

import org.codehaus.groovy.control.MultipleCompilationErrorsException;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;
import org.opentestsystem.rdw.script.impl.DefaultPipelineFactory;
import org.opentestsystem.rdw.script.publishing.PublishedPipeline;
import org.opentestsystem.rdw.script.publishing.PublishedPipelineRepository;
import org.opentestsystem.rdw.script.publishing.PublishedScript;
import org.opentestsystem.rdw.script.publishing.ScriptType;
import org.opentestsystem.rdw.script.security.SandboxSecurityManager;

import java.util.Arrays;
import java.util.Optional;

import static com.google.common.collect.Lists.newArrayList;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.when;
import static org.opentestsystem.rdw.script.publishing.ScriptType.Post;
import static org.opentestsystem.rdw.script.publishing.ScriptType.Pre;
import static org.opentestsystem.rdw.script.util.Tests.resourceAsString;

@RunWith(MockitoJUnitRunner.class)
public class PipelineFactoryTest {

    private static final PublishedScript NonCompilingScript = PublishedScript.builder()
            .body("new NoSuchThing()")
            .build();

    @Mock
    private PublishedPipelineRepository repository;

    @Mock
    private ConfigurationCompiler configurationCompiler;

    @Mock
    private PropertyResolver propertyResolver;

    @Mock
    private SandboxSecurityManager sandboxSecurityManager;

    @Mock
    private ScriptSource scriptSource;

    @Rule
    public ExpectedException exception = ExpectedException.none();

    private PipelineFactory factory;
    private PublishedPipeline publishedPipeline;
    private PublishedScript userScript;
    private PublishedScript baseScript;
    private PublishedScript preScript;
    private PublishedScript postScript;

    @Before
    public void before() throws Exception {

        final String pipelineVersion = "v";

        userScript = PublishedScript.builder()
                .type(ScriptType.User)
                .body("")
                .version(pipelineVersion)
                .build();
        baseScript = PublishedScript.builder()
                .type(ScriptType.Base)
                .body(resourceAsString("/scripts/DSLScriptBase.groovy"))
                .build();
        preScript = PublishedScript.builder()
                .type(Pre)
                .body("pre script body")
                .build();
        postScript = PublishedScript.builder()
                .type(Post)
                .body("post script body")
                .build();

        publishedPipeline = PublishedPipeline.builder()
                .pipelineCode("test")
                .version(pipelineVersion)
                .scripts(Arrays.asList(
                        userScript
                ))
                .build();

        factory = new DefaultPipelineFactory(
                repository,
                configurationCompiler,
                propertyResolver,
                sandboxSecurityManager,
                scriptSource
        );


        when(scriptSource.loadScript(ScriptType.Base, publishedPipeline.getPipelineCode()))
                .thenReturn(Optional.of(baseScript));

        when(scriptSource.loadScript(Pre, publishedPipeline.getPipelineCode()))
                .thenReturn(Optional.of(preScript));

        when(scriptSource.loadScript(Post, publishedPipeline.getPipelineCode()))
                .thenReturn(Optional.of(postScript));
    }

    @Test
    public void getPipelineShouldComposeAPipelineFromAPublishedPipeline() {

        when(repository.findByCodeAndVersion(publishedPipeline.getPipelineCode(), publishedPipeline.getVersion()))
                .thenReturn(publishedPipeline);

        final Pipeline pipeline = factory.getPipeline(publishedPipeline.getPipelineCode(), publishedPipeline.getVersion());
        assertThat(pipeline.getSource())
                .isEqualToComparingFieldByFieldRecursively(
                        publishedPipeline.copy()
                                .scripts(Arrays.asList(
                                        userScript,
                                        baseScript,
                                        preScript,
                                        postScript
                                ))
                );
    }

    @Test
    public void getPipelineShouldComposeAPipelineFromSystemScriptsWhenAPublishedPipelineIsAbsent() {
        final Pipeline pipeline = factory.getPipeline(publishedPipeline.getPipelineCode(), null);
        assertThat(pipeline.getSource())
                .isEqualToComparingFieldByFieldRecursively(
                        publishedPipeline.copy()
                                .version(null)
                                .scripts(Arrays.asList(
                                        baseScript,
                                        preScript,
                                        postScript
                                ))
                                .build()
                );
    }

    @Test
    public void getPipelineShouldAddSystemScriptsOnlyWhenPresent() {

        when(scriptSource.loadScript(Pre, publishedPipeline.getPipelineCode()))
                .thenReturn(Optional.empty());

        when(scriptSource.loadScript(Post, publishedPipeline.getPipelineCode()))
                .thenReturn(Optional.empty());

        final Pipeline pipeline = factory.getPipeline(publishedPipeline.getPipelineCode(), null);
        assertThat(pipeline.getSource())
                .isEqualToComparingFieldByFieldRecursively(
                        publishedPipeline.copy()
                                .version(null)
                                .scripts(newArrayList(
                                        baseScript
                                ))
                                .build()
                );
    }

    @Test(expected = IllegalStateException.class)
    public void getPipelineShouldThrowExceptionWhenBaseClassIsNotConfigured() {

        when(scriptSource.loadScript(ScriptType.Base, publishedPipeline.getPipelineCode()))
                .thenReturn(Optional.empty());

        factory.getPipeline(publishedPipeline.getPipelineCode(), null);
    }

    @Test(expected = IllegalArgumentException.class)
    public void getPipelineShouldThrowExceptionWhenVersionIsSpecifiedByAPipelineOfThatVersionIsNotFound() {
        factory.getPipeline(publishedPipeline.getPipelineCode(), publishedPipeline.getVersion());
    }

    @Test
    public void getPipelineShouldCorrectlyCompileAndComposeAllNonBaseScripts() {
        when(repository.findByCodeAndVersion(publishedPipeline.getPipelineCode(), publishedPipeline.getVersion()))
                .thenReturn(publishedPipeline);

        final Pipeline pipeline = factory.getPipeline(publishedPipeline.getPipelineCode(), publishedPipeline.getVersion());

        // base script is not included
        assertThat(pipeline.getScripts().size()).isEqualTo(3);

        for (final PipelineScript script : pipeline.getScripts()) {
            assertThat(script.getSource()).isNotNull();
//            assertThat(script.getCompiledScript()).isNotNull();
//
//            final ScriptType type = script.getSource().getType();
//            if (type == Pre || type == Post) {
//                assertThat(script.getPropertyResolver()).isNotNull();
//            }
        }

    }

    @Test(expected = PipelineBuildException.class)
    public void getPipelineShouldThrowExceptionWhenUserScriptDoesntCompile() {
        when(repository.findByCodeAndVersion(publishedPipeline.getPipelineCode(), publishedPipeline.getVersion()))
                .thenReturn(publishedPipeline.copy()
                        .scripts(newArrayList(
                                NonCompilingScript
                        ))
                        .build()
                );

        factory.getPipeline(publishedPipeline.getPipelineCode(), publishedPipeline.getVersion());
    }

    @Test(expected = PipelineBuildException.class)
    public void getPipelineShouldThrowExceptionWhenBaseScriptDoesntCompile() {
        when(scriptSource.loadScript(ScriptType.Base, publishedPipeline.getPipelineCode()))
                .thenReturn(Optional.of(NonCompilingScript));

        factory.getPipeline(publishedPipeline.getPipelineCode(), null);
    }

    @Test(expected = PipelineBuildException.class)
    public void getPipelineShouldThrowExceptionWhenPreScriptDoesntCompile() {
        when(scriptSource.loadScript(Pre, publishedPipeline.getPipelineCode()))
                .thenReturn(Optional.of(NonCompilingScript));

        factory.getPipeline(publishedPipeline.getPipelineCode(), null);
    }

    @Test(expected = PipelineBuildException.class)
    public void getPipelineShouldThrowExceptionWhenPostScriptDoesntCompile() {
        when(scriptSource.loadScript(Post, publishedPipeline.getPipelineCode()))
                .thenReturn(Optional.of(NonCompilingScript));

        factory.getPipeline(publishedPipeline.getPipelineCode(), null);
    }

}
