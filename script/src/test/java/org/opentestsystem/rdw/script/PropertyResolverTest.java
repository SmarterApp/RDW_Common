package org.opentestsystem.rdw.script;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;

import java.util.Arrays;

import org.opentestsystem.rdw.script.impl.DefaultConfigurationCompiler;
import org.opentestsystem.rdw.script.publishing.PublishedPipeline;
import org.opentestsystem.rdw.script.publishing.PublishedScript;
import org.opentestsystem.rdw.script.publishing.ScriptType;

import static java.util.Collections.emptyMap;
import static org.assertj.core.api.AssertionsForInterfaceTypes.assertThat;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.when;
import static org.opentestsystem.rdw.script.util.Tests.resourceAsString;

@RunWith(MockitoJUnitRunner.class)
public class PropertyResolverTest {
    private static final String PIPELINE_NAME = "My Test Pipeline";
    private static final String PIPELINE_VERSION = "1.0";
    private static final String SAFE_SCRIPT_CODE = "return 'transformed input'";
    private static final String MISSING_PROPERTY_SCRIPT_CODE = "cat.equals('cat'); " + SAFE_SCRIPT_CODE;

    private PipelineFactory pipelineFactory;
    private ScriptPipelineConfiguration config = new ScriptPipelineConfiguration();
    private ScriptDefinition userNode, systemNode;

    @Mock
    ScriptSource scriptSource;

    @Mock
    PropertyResolver propertyResolver;

    @Before
    public void before() throws Exception {
        when(propertyResolver.resolveProperty("cat")).thenReturn("cat");

        userNode = ScriptDefinition.builder()
                .source(
                        PublishedScript.builder()
                                .type(ScriptType.User)
                                .version("1.0")
                                .body("")
                                .build()
                )
                .build();

        systemNode = ScriptDefinition.builder()
                .source(
                        PublishedScript.builder()
                                .type(ScriptType.Base)
                                .version("1.0")
                                .body(resourceAsString("/scripts/DSLScriptBase.groovy"))
                                .build()
                )
                .build();

        PipelineDefinition pipelineDefinition = PipelineDefinition.builder()
                .source(
                        PublishedPipeline.builder()
                                .pipelineCode(PIPELINE_NAME)
                                .version(PIPELINE_VERSION)
                                .build()
                )
                .scripts(Arrays.asList(userNode, systemNode))
                .build();

        when(scriptSource.loadPipelineDefinition(PIPELINE_NAME, PIPELINE_VERSION))
                .thenReturn(pipelineDefinition);

        final ConfigurationCompiler configurationCompiler = new DefaultConfigurationCompiler();

        pipelineFactory = config.pipelineFactory(
                scriptSource,
                configurationCompiler,
                propertyResolver,
                null,
                resourceAsString("/scripts/DSLScriptBase.groovy")
            );
    }

    @Test
    public void itShouldUsePropertyResolverInSystemScript() {
        when(scriptSource.loadScript(systemNode)).thenReturn(
                new ScriptInfo(MISSING_PROPERTY_SCRIPT_CODE, emptyMap()));

        when(scriptSource.loadScript(userNode)).thenReturn(
                new ScriptInfo(SAFE_SCRIPT_CODE, emptyMap()));

        Pipeline pipeline = pipelineFactory.getPipeline(PIPELINE_NAME, PIPELINE_VERSION);
        PipelineResults result = pipeline.run(null);
        assertThat(result.asString()).isEqualTo("transformed input");
    }

    @Test(expected = RuntimeException.class)
    public void itShouldNotUsePropertyResolverInUserScript() {
        when(scriptSource.loadScript(any())).thenReturn(
                new ScriptInfo(MISSING_PROPERTY_SCRIPT_CODE, emptyMap()));

        Pipeline pipeline = pipelineFactory.getPipeline(PIPELINE_NAME, PIPELINE_VERSION);
        pipeline.run(null);
    }
}
