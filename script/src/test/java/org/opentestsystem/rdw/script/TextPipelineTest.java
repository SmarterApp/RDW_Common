package org.opentestsystem.rdw.script;

import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;

import java.io.IOException;
import java.util.Arrays;
import org.opentestsystem.rdw.common.model.ImportException;
import org.opentestsystem.rdw.script.impl.EmptyPropertyResolver;
import org.opentestsystem.rdw.script.impl.ResourceLoaderScriptSource;
import org.opentestsystem.rdw.script.publishing.PublishedPipelineRepository;
import org.opentestsystem.rdw.script.security.AbstractToggleableSecurityManager;
import org.opentestsystem.rdw.script.security.DefaultSandboxPermissions;
import org.opentestsystem.rdw.script.security.DefaultSandboxSecurityManager;

import static org.junit.Assert.fail;
import static org.mockito.Mockito.when;
import static org.opentestsystem.rdw.script.util.Tests.resourceAsString;

@RunWith(MockitoJUnitRunner.class)
public class TextPipelineTest {
    private static final String PIPELINE_NAME = "My Test Pipeline";
    private static final String PIPELINE_VERSION = "1.0";

    private PipelineFactory pipelineFactory;
    private ScriptPipelineConfiguration config = new ScriptPipelineConfiguration();

    private static AbstractToggleableSecurityManager sandboxSecurityManager;

    @Mock
    private PublishedPipelineRepository repository;

    private PipelineDefinition pipelineDefinition;

    @BeforeClass
    public static void setupSecurityManager() {
        sandboxSecurityManager = new DefaultSandboxSecurityManager(new DefaultSandboxPermissions());
    }

    @Before
    public void before() {

        pipelineDefinition = PipelineDefinition.builder()
                .pipelineCode(PIPELINE_NAME)
                .version(PIPELINE_VERSION)
                .scripts(Arrays.asList(
                        PipelineScriptDefinition.builder()
                                .type(PipelineScriptType.User)
                                .version("1.0")
                                .body("")
                                .build(),
                        PipelineScriptDefinition.builder()
                                .type(PipelineScriptType.Base)
                                .version("1.0")
                                .body(resourceAsString("/scripts/DSLScriptBase.groovy"))
                                .build()
                ))
                .build();

        when(repository.findByCodeAndVersion(PIPELINE_NAME, PIPELINE_VERSION))
                .thenReturn(pipelineDefinition);

        PropertyResolver propertyResolver = new EmptyPropertyResolver();

        pipelineFactory = config.pipelineFactory(
                repository,
                propertyResolver,
                sandboxSecurityManager,
                new ResourceLoaderScriptSource()
        );
    }

    @Test(expected = ImportException.class)
    public void itShouldFailOnValidationErrors() throws Exception {
        // Test ability to filter out elements with a boolean rule. All elements matching the XPath expression
        // and also matching this rule will be removed.
        final String scriptCode =
                        "addError('element', 'expected value', 'actual value is actual')\n" +
                        "checkValid";

        when(repository.findByCodeAndVersion(PIPELINE_NAME, PIPELINE_VERSION))
                .thenReturn(pipelineWithUserScript(scriptCode));

        Pipeline pipeline = pipelineFactory.getPipeline(PIPELINE_NAME, PIPELINE_VERSION);

        try {
            pipeline.run("good input");
        } catch (ScriptRuntimeException sre) {
            throw (Exception)sre.getCause();
        }
    }

    @Test
    public void itShouldNotCarryOverValidationErrors() throws Exception {
        final String scriptCode =
                        "if (input == 'bad input')\n" +
                        "    addError('element', 'expected value', 'bad input')\n" +
                        "checkValid";

        when(repository.findByCodeAndVersion(PIPELINE_NAME, PIPELINE_VERSION))
                .thenReturn(pipelineWithUserScript(scriptCode));

        Pipeline pipeline = pipelineFactory.getPipeline(PIPELINE_NAME, PIPELINE_VERSION);

        try {
            pipeline.run("bad input");
            fail("Expected a script exception for bad input");
        } catch (ScriptRuntimeException sre) {
        }

        pipeline.run("good input");
    }

    private PipelineDefinition pipelineWithUserScript(final String userScript) throws IOException {
        return PipelineDefinition.builder()
                .pipelineCode(PIPELINE_NAME)
                .version(PIPELINE_VERSION)
                .scripts(Arrays.asList(
                        PipelineScriptDefinition.builder()
                                .type(PipelineScriptType.User)
                                .version("1.0")
                                .body(userScript)
                                .build(),
                        PipelineScriptDefinition.builder()
                                .type(PipelineScriptType.Base)
                                .version("1.0")
                                .body(resourceAsString("/scripts/DSLScriptBase.groovy"))
                                .build()
                ))
                .build();
    }

}
