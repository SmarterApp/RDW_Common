
package org.opentestsystem.rdw.script.publishing;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;
import org.opentestsystem.rdw.archive.ArchiveService;
import org.opentestsystem.rdw.script.impl.ResourceLoaderScriptSource;

import java.time.Instant;
import java.util.List;
import java.util.Properties;

import static com.google.common.collect.Lists.newArrayList;
import static java.nio.charset.StandardCharsets.UTF_8;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import static org.opentestsystem.rdw.script.publishing.PublishedPipelines.toProperties;
import static org.opentestsystem.rdw.script.publishing.ScriptType.Base;
import static org.opentestsystem.rdw.script.publishing.ScriptType.Post;
import static org.opentestsystem.rdw.script.publishing.ScriptType.Pre;
import static org.opentestsystem.rdw.script.publishing.ScriptType.User;
import static org.opentestsystem.rdw.script.util.Tests.resourceAsString;


@RunWith(MockitoJUnitRunner.class)
public class ArchiveBackedPublishedPipelineRepositoryTest {

    @Mock
    private ArchiveService archiveService;
    private ArchiveBackedPublishedPipelineRepository repository;

    @Before
    public void before() {
        repository = new ArchiveBackedPublishedPipelineRepository(
                archiveService,
                new ResourceLoaderScriptSource()
        );
    }

    @Test
    public void findAllByCodeShouldReturnNothingWhenEmpty() {
        final List<PublishedPipeline> publishedPipelines = repository.findAllByCode("code");
        assertThat(publishedPipelines).isEmpty();
        verify(archiveService).listResources("pipelines/code");
    }

    @Test
    public void findAllByCodeShouldCallArchiveService() {

        final String pipelineCode = "code";
        final String userScriptPrefix = "pipelines/" + pipelineCode;
        final String userScriptPath = "pipelines/" + pipelineCode + "/user.1.groovy";
        final Instant published = Instant.now();
        final String publishedBy = "publisher";
        final PublishedPipeline publishedPipeline = PublishedPipeline.builder()
                .pipelineCode(pipelineCode)
                .version("1")
                .published(published)
                .publishedBy(publishedBy)
                .build();

        when(archiveService.listResources(userScriptPrefix))
                .thenReturn(newArrayList(
                        userScriptPath
                ));

        when(archiveService.readProperties(userScriptPath))
                .thenReturn(toProperties(publishedPipeline));


        assertThat(repository.findAllByCode(pipelineCode))
                .usingRecursiveFieldByFieldElementComparator()
                .containsExactly(
                        publishedPipeline
                );
    }

    @Test
    public void findByCodeAndVersionShouldFind() throws Exception {
        final PublishedPipeline published = PublishedPipeline.builder()
                .pipelineCode("code")
                .version("5")
                .published(Instant.now())
                .publishedBy("publisher")
                .scripts(newArrayList(
                        PublishedScript.builder()
                                .type(User)
                                .version("5")
                                .body("body")
                                .build(),
                        PublishedScript.builder()
                                .type(Base)
                                .body(resourceAsString("/scripts/DSLScriptBase.groovy"))
                                .build()
                ))
                .build();

        when(archiveService.exists(anyString())).thenReturn(true);
        when(archiveService.readResource(anyString())).thenReturn("body".getBytes());
        when(archiveService.readProperties(anyString())).thenReturn(toProperties(published));

        final PublishedPipeline pipeline = repository
                .findByCodeAndVersion(published.getPipelineCode(), published.getVersion());

        assertThat(pipeline).isEqualToComparingFieldByFieldRecursively(published);
    }

    @Test
    public void findByCodeAndVersionShouldLoadScriptsIfPresent() throws Exception {

        final PublishedPipeline publishedPipeline = PublishedPipeline.builder()
                .pipelineCode("test")
                .version("v")
                .published(Instant.now())
                .publishedBy("by")
                .scripts(newArrayList(
                        PublishedScript.builder()
                                .type(User)
                                .version("v")
                                .body("user script body")
                                .build(),
                        PublishedScript.builder()
                                .type(Base)
                                .body(resourceAsString("/scripts/DSLScriptBase.groovy"))
                                .build(),
                        PublishedScript.builder()
                                .type(Pre)
                                .body("pre script body")
                                .build(),
                        PublishedScript.builder()
                                .type(Post)
                                .body("post script body")
                                .build()
                ))
                .build();

        final String userScriptPath = String.format(
                "pipelines/%s/user.%s.groovy",
                publishedPipeline.getPipelineCode(),
                publishedPipeline.getVersion()
        );

        when(archiveService.exists(userScriptPath)).thenReturn(true);
        when(archiveService.readResource(userScriptPath)).thenReturn("user script body".getBytes(UTF_8));
        when(archiveService.readProperties(userScriptPath)).thenReturn(toProperties(publishedPipeline));

        assertThat(repository.findByCodeAndVersion(publishedPipeline.getPipelineCode(), publishedPipeline.getVersion()))
                .isEqualToComparingFieldByFieldRecursively(publishedPipeline);
    }

    @Test
    public void createShouldStartVersionAtOne() {
        final String pipelineCode = "code";
        final String pipelinePathPrefix = "pipelines/" + pipelineCode;

        when(archiveService.listResources(pipelinePathPrefix))
                .thenReturn(newArrayList());

        assertThat(repository.create(
                PublishedPipeline.builder()
                        .pipelineCode(pipelineCode)
                        .build()
        ).getVersion()).isEqualTo("1");
    }

    @Test
    public void createShouldBumpVersion() throws Exception {

        final PublishedPipeline publishedPipeline = PublishedPipeline.builder()
                .pipelineCode("test")
                .version("1")
                .published(Instant.now())
                .publishedBy("by")
                .scripts(newArrayList(
                        PublishedScript.builder()
                                .type(User)
                                .version("1")
                                .body("user script body")
                                .build(),
                        PublishedScript.builder()
                                .type(Base)
                                .body(resourceAsString("/scripts/DSLScriptBase.groovy"))
                                .build()
                ))
                .build();

        final String pipelinePathPrefix = "pipelines/" + publishedPipeline.getPipelineCode();
        final String userScriptPath = "pipelines/" + publishedPipeline.getPipelineCode() + "/user.1.groovy";

        when(archiveService.listResources(pipelinePathPrefix))
                .thenReturn(newArrayList(
                        userScriptPath
                ));

        when(archiveService.readProperties(userScriptPath))
                .thenReturn(toProperties(publishedPipeline));

        assertThat(repository.create(
                PublishedPipeline.builder()
                        .pipelineCode(publishedPipeline.getPipelineCode())
                        .build()
        ).getVersion()).isEqualTo("2");
    }

    @Test
    public void createShouldNotWriteUserScriptIfAbsent() {

        final PublishedPipeline pipeline = PublishedPipeline.builder()
                .pipelineCode("code")
                .build();

        repository.create(pipeline);

        final ArgumentCaptor<String> path = ArgumentCaptor.forClass(String.class);
        final ArgumentCaptor<byte[]> resource = ArgumentCaptor.forClass(byte[].class);
        final ArgumentCaptor<Properties> properties = ArgumentCaptor.forClass(Properties.class);
        verify(archiveService, times(0)).writeResource(path.capture(), resource.capture(), properties.capture());

        assertThat(path.getAllValues()).doesNotContain("pipelines/code/user.1.groovy");
    }

    @Test
    public void createShouldWriteUserScriptIfPresent() {

        final PublishedPipeline pipeline = PublishedPipeline.builder()
                .pipelineCode("code")
                .version("v")
                .published(Instant.now())
                .publishedBy("by")
                .scripts(newArrayList(
                        PublishedScript.builder()
                                .type(User)
                                .body("body")
                                .build()
                ))
                .build();

        repository.create(pipeline);

        final ArgumentCaptor<String> path = ArgumentCaptor.forClass(String.class);
        final ArgumentCaptor<byte[]> resource = ArgumentCaptor.forClass(byte[].class);
        final ArgumentCaptor<Properties> properties = ArgumentCaptor.forClass(Properties.class);
        verify(archiveService, times(1))
                .writeResource(path.capture(), resource.capture(), properties.capture());

        assertThat(path.getAllValues()).contains("pipelines/code/user.1.groovy");
    }
}
