
package org.opentestsystem.rdw.script.publishing;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;

import java.time.Instant;
import java.util.List;
import java.util.Optional;
import java.util.Properties;
import org.opentestsystem.rdw.archive.ArchiveService;
import org.opentestsystem.rdw.script.impl.ResourceLoaderScriptSource;
import org.opentestsystem.rdw.script.util.Tests;

import static com.google.common.collect.Lists.newArrayList;
import static java.nio.charset.StandardCharsets.UTF_8;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import static org.opentestsystem.rdw.script.publishing.ScriptType.Base;
import static org.opentestsystem.rdw.script.publishing.ScriptType.User;


@RunWith(MockitoJUnitRunner.class)
public class ArchiveBackedPublishedPipelineRepositoryTest {

    @Mock
    private ArchiveService archiveService;
    private ArchiveBackedPublishedPipelineRepository repository;

    @Before
    public void before() {
        repository = new ArchiveBackedPublishedPipelineRepository(
                archiveService,
                new ResourceLoaderScriptSource()
        );
    }

    @Test
    public void findAllByCodeShouldReturnNothingWhenEmpty() {
        final List<PublishedPipeline> publishedPipelines = repository.findAllByCode("code");
        assertThat(publishedPipelines).isEmpty();
        verify(archiveService).listResources("pipelines/code");
    }

    @Test
    public void findAllByCodeShouldCallArchiveService() {

        final String pipelineCode = "code";
        final String userScriptPrefix = "pipelines/" + pipelineCode;
        final String userScriptPath = "pipelines/" + pipelineCode + "/user.1.groovy";
        final Instant published = Instant.now();
        final String publishedBy = "publisher";

        when(archiveService.listResources(userScriptPrefix))
                .thenReturn(newArrayList(
                        userScriptPath
                ));

        when(archiveService.readProperties(userScriptPath))
                .thenReturn(publishedProperties(published, publishedBy));


        assertThat(repository.findAllByCode(pipelineCode))
                .usingRecursiveFieldByFieldElementComparator()
                .containsExactly(
                        PublishedPipeline.builder()
                                .pipelineCode(pipelineCode)
                                .version("1")
                                .published(published)
                                .publishedBy(publishedBy)
                                .build()
                );
    }

    @Test
    public void findByCodeAndVersionShouldFind() throws Exception {

        final String pipelineCode = "code";
        final String pipelineVersion = "5";
        final Instant published = Instant.now();
        final String publishedBy = "publisher";
        final String userScriptBody = "body";


        when(archiveService.exists(anyString())).thenReturn(true);
        when(archiveService.readResource(anyString())).thenReturn(userScriptBody.getBytes());
        when(archiveService.readProperties(anyString())).thenReturn(publishedProperties(published, publishedBy));

        final PublishedPipeline pipeline = repository.findByCodeAndVersion(pipelineCode, pipelineVersion);

        assertThat(pipeline.getPipelineCode()).isEqualTo(pipelineCode);
        assertThat(pipeline.getVersion()).isEqualTo(pipelineVersion);
        assertThat(pipeline.getPublished()).isEqualTo(published);
        assertThat(pipeline.getPublishedBy()).isEqualTo(publishedBy);
        assertThat(getByType(Base, pipeline.getScripts())).isPresent();
        assertThat(getByType(User, pipeline.getScripts())).isPresent();
        assertThat(getByType(User, pipeline.getScripts()).get().getBody()).isEqualTo(userScriptBody);
    }

    private Properties publishedProperties(final Instant published, final String publishedBy) {
        final Properties properties = new Properties();
        properties.setProperty("published", published.toString());
        properties.setProperty("publishedBy", publishedBy);

        return properties;
    }

    private Optional<PublishedScript> getByType(final ScriptType type, final List<PublishedScript> scripts) {
        return scripts.stream().filter(s -> s.getType() == type).findAny();
    }

    @Test
    public void findByCodeAndVersionShouldLoadScriptsIfPresent() throws Exception {

        final String pipelineCode = "test";
        final String pipelineVersion = "5";
        final String userScriptPath = "pipelines/" + pipelineCode + "/user." + pipelineVersion + ".groovy";
        final Instant published = Instant.now();
        final String publishedBy = "publisher";

        final String baseScript = Tests.resourceAsString("/scripts/DSLScriptBase.groovy");

        when(archiveService.exists(userScriptPath)).thenReturn(true);
        when(archiveService.readResource(userScriptPath)).thenReturn("user script body".getBytes(UTF_8));
        when(archiveService.readProperties(userScriptPath)).thenReturn(publishedProperties(published, publishedBy));

        assertThat(repository.findByCodeAndVersion(pipelineCode, pipelineVersion))
                .isEqualToComparingFieldByFieldRecursively(
                        PublishedPipeline.builder()
                                .pipelineCode(pipelineCode)
                                .version(pipelineVersion)
                                .published(published)
                                .publishedBy(publishedBy)
                                .scripts(newArrayList(
                                        PublishedScript.builder()
                                                .type(User)
                                                .version(pipelineVersion)
                                                .body("user script body")
                                                .build(),
                                        PublishedScript.builder()
                                                .type(Base)
                                                .body(baseScript)
                                                .build(),
                                        PublishedScript.builder()
                                                .type(ScriptType.Pre)
                                                .body("pre script body")
                                                .build(),
                                        PublishedScript.builder()
                                                .type(ScriptType.Post)
                                                .body("post script body")
                                                .build()
                                ))
                                .build()
                );
    }

    @Test
    public void createShouldStartVersionAtOne() {
        final String pipelineCode = "code";
        final String pipelinePathPrefix = "pipelines/" + pipelineCode;

        when(archiveService.listResources(pipelinePathPrefix))
                .thenReturn(newArrayList());

        assertThat(repository.create(
                PublishedPipeline.builder()
                        .pipelineCode(pipelineCode)
                        .build()
        ).getVersion()).isEqualTo("1");
    }

    @Test
    public void createShouldBumpVersion() throws Exception {

        final String pipelineCode = "code";
        final String pipelinePathPrefix = "pipelines/" + pipelineCode;
        final String userScriptPath = "pipelines/" + pipelineCode + "/user.1.groovy";
        final Instant published = Instant.now();
        final String publishedBy = "publisher";

        when(archiveService.listResources(pipelinePathPrefix))
                .thenReturn(newArrayList(
                        userScriptPath
                ));

        when(archiveService.readProperties(userScriptPath)).thenReturn(publishedProperties(published, publishedBy));

        assertThat(repository.create(
                PublishedPipeline.builder()
                        .pipelineCode(pipelineCode)
                        .build()
        ).getVersion()).isEqualTo("2");
    }

    @Test
    public void createShouldNotWriteUserScriptIfAbsent() {

        final PublishedPipeline pipeline = PublishedPipeline.builder()
                .pipelineCode("code")
                .build();

        repository.create(pipeline);

        final ArgumentCaptor<String> path = ArgumentCaptor.forClass(String.class);
        final ArgumentCaptor<byte[]> resource = ArgumentCaptor.forClass(byte[].class);
        final ArgumentCaptor<Properties> properties = ArgumentCaptor.forClass(Properties.class);
        verify(archiveService, times(0)).writeResource(path.capture(), resource.capture(), properties.capture());

        assertThat(path.getAllValues()).doesNotContain("pipelines/code/user.1.groovy");
    }

    @Test
    public void createShouldWriteUserScriptIfPresent() {

        final PublishedPipeline pipeline = PublishedPipeline.builder()
                .pipelineCode("code")
                .scripts(newArrayList(
                        PublishedScript.builder()
                                .type(User)
                                .body("body")
                                .build()
                ))
                .build();

        repository.create(pipeline);

        final ArgumentCaptor<String> path = ArgumentCaptor.forClass(String.class);
        final ArgumentCaptor<byte[]> resource = ArgumentCaptor.forClass(byte[].class);
        final ArgumentCaptor<Properties> properties = ArgumentCaptor.forClass(Properties.class);
        verify(archiveService, times(1))
                .writeResource(path.capture(), resource.capture(), properties.capture());

        assertThat(path.getAllValues()).contains("pipelines/code/user.1.groovy");
    }
}