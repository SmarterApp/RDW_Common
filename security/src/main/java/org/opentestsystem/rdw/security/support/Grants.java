package org.opentestsystem.rdw.security.support;

import org.opentestsystem.rdw.security.Grant;

import static com.google.common.base.Strings.emptyToNull;

/**
 * Utility class containing all methods related to tenancy chains
 * The tenancy chain abstraction refers to a role grant scoped to a specific system entity.
 * Tenancy chain grants are transmitted in the following form as string literals:
 * |EntityID|Role|Level|ClientID|Client|GroupOfStateID|GroupOfStates|StateID|State|GroupOfDistrictsID|GroupOfDistricts|DistrictID|District|GroupOfInstitutionsID|GroupOfInstitutions|InstitutionID|Institution
 */
public final class Grants {

	private Grants() {}

	/**
	 * Transforms a raw tenancy chain grant string into an array of tenancy chain property values
	 * @param grant the raw tenancy chain grant literal (example: )
	 * @return array of grant tokens
	 */
	private static String[] tokenize(final String grant) {
		if (grant == null) {
			throw new NullPointerException("grant must not be null");
		}
		final String[] tokens = grant.split("\\|");
		if (tokens.length != 18) {
			throw new IllegalArgumentException(
				String.format("Error tokenizing tenancy chain grant. Grant \"%s\" does not container 17 \"|\" delimiters", grant));
		}
		return tokens;
	}

	/**
	 * Creates an object representation for the given tenancy chain grant to allow for named-property lookups.
	 * @param grant the raw tenancy chain grant (example: "|CA|PII|STATE|||||CA|California||||||||")
	 * @return an object representation of the given tenancy chain grant
	 */
	public static Grant from(final String grant) {
		final String[] tokens = tokenize(grant);
		return Grant.builder()
			.entityId(emptyToNull(tokens[1]))
			.role(emptyToNull(tokens[2]))
			.entityLevel(Grant.EntityLevel.valueOf(emptyToNull(tokens[3])))
			.clientId(emptyToNull(tokens[4]))
			.clientName(emptyToNull(tokens[5]))
			.stateGroupId(emptyToNull(tokens[6]))
			.stateGroupName(emptyToNull(tokens[7]))
			.stateId(emptyToNull(tokens[8]))
			.stateName(emptyToNull(tokens[9]))
			.districtGroupId(emptyToNull(tokens[10]))
			.districtGroupName(emptyToNull(tokens[11]))
			.districtId(emptyToNull(tokens[12]))
			.districtName(emptyToNull(tokens[13]))
			.institutionGroupId(emptyToNull(tokens[14]))
			.institutionGroupName(emptyToNull(tokens[15]))
			.institutionId(emptyToNull(tokens[16]))
			.institutionName(emptyToNull(tokens[17]))
			.build();
	}

	/**
	 * Determines if the given grant "a" contains or equals the given grant "b".
	 * Used to remove redundancy in collections of tenancy chain grants.
	 * @param a the possible container of grant "b"
	 * @param b the possible continents of grant "a" for which the continents test is performed
	 * @return true if grant "a" contains or equals grant "b".
	 */
	public static boolean contains(final Grant a, final Grant b) {

		/*
			If the roles do not match, there is no need to compare the scope of the grant
		 */
		return a.getRole().equals(b.getRole())
			&& (
				/*
					If the grants have the same role and are for the same entity, they are equal.
				 */
				a.getEntityId().equals(b.getEntityId())

				/*
					If the access scope of grant b is less granular than grant a then grant a cannot contain it
				 */
				|| a.getEntityLevel().getGranularity() < b.getEntityLevel().getGranularity()
				&& (
					/*
						Look for the first occasion (if any) where a scope qualifier matches
						If a match is found then a contains b
						Do not compare if either is null, sometimes these qualifiers are not specified when
						permission is not granted to the role for a given entity level
					 */
					(a.getStateGroupId() != null && b.getStateGroupId() != null && a.getStateGroupId().equals(b.getStateGroupId()))
					|| (a.getStateId() != null && b.getStateId() != null && a.getStateId().equals(b.getStateId()))
					|| (a.getDistrictGroupId() != null && b.getDistrictGroupId() != null && a.getDistrictGroupId().equals(b.getDistrictGroupId()))
					|| (a.getDistrictId() != null && b.getDistrictId() != null && a.getDistrictId().equals(b.getDistrictId()))
					|| (a.getInstitutionGroupId() != null && b.getInstitutionGroupId() != null && a.getInstitutionGroupId().equals(b.getInstitutionGroupId()))
				)
		);
	}

	/**
	 * Determines if the given grants have a grant containing or equaling the given grant
	 * @param grants collection of grants in which containership is being tested
	 * @param grant the grant for which containership is being tested
	 * @return true if grants have a grant which contains the given grant
	 */
	public static boolean contains(final Iterable<Grant> grants, final Grant grant) {
		for (Grant containerCandidate : grants) {
			if (contains(containerCandidate, grant)) {
				return true;
			}
		}
		return false;
	}

}